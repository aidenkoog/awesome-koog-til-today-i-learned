#### 코틀린의 타켓 플랫폼 설명 / 자바와 서로 상호 운용에 대한 설명

- JVM이 코틀린의 타켓 플랫폼
- 코틀린은 컴파일 시 바이트 코드를 생성하므로 자바와 100% 상호 운용 가능
- 따라서 자바 <-> 코틀린 코드 간 상호 참조 / 호출 가능

#### Kotlin Scope Function 설명

- 객체에 쉽게 접근할 수 있도록 해주는 함수
- 코드가 간결해지고 가독성 증대 효과
- 시용 시 리시버와 람다 함수를 넘겨줌
- Scope 함수는 어떠한 새로운 기술적인 능력을 가져다주는 것이 아닌, 코드를 좀 더 간결하고 읽기 쉽게 만들어주는 것
- Scope Function에는 서로 다른 두 가지 주요 차이점
  - Context Object를 참조하는 방법 (this, it)
  - Return value
- apply
  - this로 Context 객체 참조
  - Context 객체 반환
  - 객체의 상태를 변화시키고 그 객체를 다시 반환할 때 사용
- with
  - this로 Context 객체 참조
  - 람다식 결과 반환
  - 인수로 전달되는 자기자신을 this로 참조.
  - this 키워드를 생략할 수도 있고, 리턴값 생략을 권장
  - let은 리시버의 확장함수로 쓰이지만 with은 그렇지 않음.
  - 리시버객체는 with(리시버객체){람다함수}로 인자로만 전달 가능
- run
  - this로 Context 객체 참조
  - 람다식 결과 반환
  - with과 다르게 확장함수로 쓸 수 있음
  - 리시버객체를 리시버객체.run{람다함수}처럼 함수처럼 사용 가능
  - run()함수는 람다함수에서 여러값을 초기화하고, 리턴값을 어떤 객체의 초기값으로 사용
  - let()함수로 똑같이 쓸 수도 있는데 차이점이라면 run()함수는 굳이 확장함수로 사용하지 않을때도 사용 가능
    - ex. run {}
  - run()함수는 익명함수처럼 사용하거나 객체에서 호출하는 방법 모두 제공
- let
  - it으로 Context 객체(리시버) 참조 (전달 인자명 지정 안하면 it)
  - 람다식 결과 반환
  - 한번에 여러 함수를 호출할 때 사용
  - ?키워드와 같이 쓰이면서 널이 아닐 때만 리시버가 동작하도록 할때 사용
- also
  - it으로 Context 객체(리시버) 참조 (전달 인자명 지정 안하면 it)
  - Context 객체 반환
  - let()과 기능은 비슷하지만, apply처럼 객체의 상태를 변화시키고 그 객체를 다시 반환할때 사용
  - 리시버 스스로를 리턴하기 때문에 연속적으로 객체 호출 가능

#### by lazy 와 lateinit 설명

- lateinit: var 에서만 사용 가능
  - 언제든 초기화 변경 가능
  - null 통한 초기화 불가능
  - 초기화 전 접근 불가능 (lateinit property subject has not been initialized 에러)
  - 변수에 대한 setter/getter 프로퍼티 정의 불가능
  - 원시 타입에 대해서는 활용 불가능
  - 초기화 확인 방법 => ::변수.isInitialized
- by lazy: val 에서만 사용 가능
  - lazy {}에 생성과 동시에 값을 초기화 하는 방법 사용
  - 호출 시점에 by lazy 정의에 의해 초기화 진행
  - val 에서만 사용 가능
  - 값 교체 불가능
  - 기본 Synchronized 로 동작

#### 동일성 (===)과 동등성 (==) 비교 방법 설명

- 동일성 (equality)
  - 두 개의 오브젝트가 완전히 동일한 것을 의미
- 동등성 (identity)
  - 동일한 정보를 가지고 있는 오브젝트를 의미

#### Companion Object 설명

- 클래스가 메모리에 적재되면서 함께 생성되는 객체 (자바 Static 처럼 사용 가능)
- Static 과 다름 (Static 보다 더 많은 일)
- Companion Object 는 변수에 할당 가능, 변수를 통해 멤버 참조도 가능
- 객체 생성 없이 변수와 메소드 등을 선언하여 사용하기 위해 사용

#### object 설명

- 싱글턴 패턴을 적용하여 객체를 한번만 생성하도록 하기 위해 사용하거나 익명 클래스의 생성을 위해 사용

#### 접근 제한자 설명

- private
  - 해당 파일 또는 클래스에서만 사용 가능
- public
  - 어디서든 접근 가능, 함수 또는 클래스 앞에 아무 접근자도 붙이지 않으면 자동으로 기본 지정되어서 따로 명시할 필요 없음
- protected
  - 상속받는 인터페이스, 클래스 또는 자식 클래스에서만 접근 가능
- internal
  - 같은 모듈 안에서는 다 접근 가능

#### Mutable과 Immutable 의미 및 존재 이유 설명

- 코틀린 콜렉션에서 제공하는 2가지 타입의 인터페이스
- 변경 가능 여부에 따라 2가지로 구분
- 코틀린은 불변성을 권장
- 불변성이 중요한 함수형 프로그래밍을 돕기 위해 사용

#### 코틀린 장점 설명

- 기존의 자바 코드의 보일러 플레이트 구문 최소화 가능
- 자바 8 / RxJava / 람다 등의 활용을 통해 코드 간소화가 가능하나 라이브러리들의 의존성문제와 기존 라이브러리에 대한 학습등이 부담으로 다가오는 문제점 존재
- NullPointerException 핸들링
- 보일러 플레이트 개선 (데이터 클래스 등)
- Collections에 filter, map, foreach 같은 고차함수를 적용 가능
- 변경 가능한 컬렉션과 불가능한 컬렉션을 엄격히 구분
- 서버에서 수신받은 데이터를 컬렉션으로 다룰 일이 많기때문에 코드를 보다 간결하고, 안전하게 만드는 데 도움이 됨 - 확장함수(이미 존재하는 클래스에 새로운 함수를 추가)라는 기능 제공
- 자바와 호환성이 무척 좋고 기존의 라이브러리를 제약없이 사용 가능

#### 코틀린 inline 함수 / 클래스 설명 (스터디 및 추가 정리 필요)

- 자바에서는 제공하지 않음
- 람다식 사용 시 무의미한 객체 생성 방지
- 람다식 내 로컬 변수 추가되는 것에 대한 개선
- public inline 함수는 private 함수 호출 불가능
- 참고. 람다의 경우 컴파일 단계에서 파라미터 개수에 따라 Function 형태의 인터페이스로 변환됨
- inline 키워드를 사용하면 함수를 호출하는 모든 문장을 함수 본문에 해당하는 바이트코드로 바꿔주기 때문에 오버헤드를 감소시킴

#### 코틀린 확장함수 (Extension Function)

- 클래스에는 다양한 매소드(함수)들이 존재하는데, 이때 기존의 클래스에 내가 원하는 새로운 함수를 추가(확장)하려고 할 때 사용하는 함수
- 기존의 클래스에 새로운 함수를 확장한다라는 의미
- 만약 모든 클래스에 내가 만든 확장함수를 추가하고 싶다면 최상위 클래스인 'Any'에 확장 함수를 구현하면 가능
- 코틀린의 최상위 요소는 'Any'이기 때문에 Any에 확장 함수를 추가하면 코틀린의 모든 요소에 상속되기 때문에 모든 클래스에 내가 만든 확장함수를 추가 가능
- 개발 시 확장함수를 잘 설계해서 정의해놓으면 효율적인 코드 작성 가능
- 기존에 정의된 클래스에 함수를 추가하는 기능
- 보통 자기가 만든 클래스에 함수를 추가하려면 [클래스명].[함수명]을 할 수 있지만 기존에 정의된 클래스에 함수를 추가하기 위해선 확장함수를 정의해야 함

#### 코루틴 정리

- co : with, together 
- routine : 규칙적으로 하는일의 통상적인 순서와 방법
- coroutine : co + routine의 합성어로 협동루틴
- 즉, 코루틴이란 함께 동작하면서 규칙이 있는 일의 순서를 의미
- 코루틴은 실행이 마지막으로 중단되었던 지점의 바로 다음장소에서 실행을 재개
- 동기는 launch, 비동기는 async로 표현
  - Builder: launch, async, 코루틴을 실행하는 함수
- Main: 메인 스레드. 화면 UI 작업 등을 하는 곳
- IO: 네트워크, DB 등 백그라운드에서 필요한 작업을 하는 곳
- Default: 정렬이나 무거운 계산 작업 등을 하는 곳
- Coroutines simplify async code by replcaing callbacks
- 구글에서는 코루틴을 비동기처리에서 쓰면 코드를 간단하게 작성할 수 있다고 함
- 코루틴이 메인스레드가 blocking되는 부분에 대해서도 도움을 주고 비동기 처리코드를 순차적인 코드로 만들수 있게 해줌
- delay는 no blocking, sleep은 blocking 함수
- CoroutineScope: 코루틴을 제어할 수 있는 범위
- CoroutineContext: 코루틴이 실행될 Context, 코루틴의 실행 목적에 맞게 실행될 특정 스레드풀을 지정

#### 고차함수 (higher-order functions)

- 함수의 인자로 함수를 넘기거나 함수를 리턴할 수 있는 기능
- 인자로 함수를 넘길때 함수의 타입 명시 필요, ex. func: ()->String 처럼 함수의 타입이 String
- ->를 기준으로 왼쪽은 파라미터(인자), 오른쪽은 리턴값을 의미
- 리턴값이 없으면 Unit으로 표기

#### 코틀린 runCatching

- inline 키워드가 붙어 있고 내부적으로 try-catch를 쓰고 있음
- 리턴 타입은 매개변수로 받은 함수 타입이 반환하는 값과 같은 값을 갖는 Result 타입
- 성공 시 Result.success() 안에서 함수 타입 매개변수를 실행해 리턴하고 실패 시 Result.failure()로 Throwable을 넘김
- runCatching {} 안에는 예외가 발생할 수 있는 코드를 삽입
- 그리고 뒤에 잇따르는 onSuccess, onFailure 블록에선 각각 성공, 실패한 경우 수행할 처리들을 삽입
- 마지막에 result 변수를 출력하면 Success()에 감싸여 있는 걸 볼 수 있음
- 위에서 말한 대로 호출이 성공해서 Result 타입으로 캡슐화된 응답이 반환된 것임
- try-catch 보다 간결한 형태로 예외처리 코드를 쓸 수 있어 상대적으로 가독성이 좋음
- onSuccess, onFailure, getOrElse 등의 함수를 연달아 쓸 수 있는 함수 체이닝이 가능
- Result 타입을 사용해 성공 / 실패를 리턴하기 때문에 try-catch보다 상대적으로 성능 저하가 일어날 수 있음

