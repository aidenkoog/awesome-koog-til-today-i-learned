#### 코틀린의 타켓 플랫폼 설명 / 자바와 서로 상호 운용에 대한 설명

- JVM이 코틀린의 타켓 플랫폼
- 코틀린은 컴파일 시 바이트 코드를 생성하므로 자바와 100% 상호 운용 가능
- 따라서 자바 <-> 코틀린 코드 간 상호 참조 / 호출 가능

#### Kotlin Scope Function 설명

- Scope 함수는 어떠한 새로운 기술적인 능력을 가져다주는 것이 아닌, 코드를 좀 더 간결하고 읽기 쉽게 만들어주는 것
- Scope Function에는 서로 다른 두 가지 주요 차이점
  - Context Object를 참조하는 방법 (this, it)
  - Return value
- apply
  - this로 Context 객체 참조
  - Context 객체 반환
- with
  - this로 Context 객체 참조
  - 람다식 결과 반환
- run
  - this로 Context 객체 참조
  - 람다식 결과 빈환
- let
  - it으로 Context 객체 참조 (전달 인자명 지정 안하면 it)
  - 람다식 결과 반환
- also
  - it으로 Context 객체 참조 (전달 인자명 지정 안하면 it)
  - Context 객체 반환

#### by lazy 와 lateinit 설명

- lateinit: var 에서만 사용 가능
  - 언제든 초기화 변경 가능
  - null 통한 초기화 불가능
  - 초기화 전 접근 불가능 (lateinit property subject has not been initialized 에러)
  - 변수에 대한 setter/getter 프로퍼티 정의 불가능
  - 원시 타입에 대해서는 활용 불가능
  - 초기화 확인 방법 => ::변수.isInitialized
- by lazy: val 에서만 사용 가능
  - lazy {}에 생성과 동시에 값을 초기화 하는 방법 사용
  - 호출 시점에 by lazy 정의에 의해 초기화 진행
  - val 에서만 사용 가능
  - 값 교체 불가능
  - 기본 Synchronized 로 동작

#### 동일성 (===)과 동등성 (==) 비교 방법 설명

- 동일성 (equality)
  - 두 개의 오브젝트가 완전히 동일한 것을 의미
- 동등성 (identity)
  - 동일한 정보를 가지고 있는 오브젝트를 의미

#### Companion Object 설명

- 클래스가 메모리에 적재되면서 함께 생성되는 객체 (자바 Static 처럼 사용 가능)
- Static 과 다름 (Static 보다 더 많은 일)
- Companion Object 는 변수에 할당 가능, 변수를 통해 멤버 참조도 가능
- 객체 생성 없이 변수와 메소드 등을 선언하여 사용하기 위해 사용

#### object 설명

- 싱글턴 패턴을 적용하여 객체를 한번만 생성하도록 하기 위해 사용하거나 익명 클래스의 생성을 위해 사용

#### 접근 제한자 설명

- private
  - 해당 파일 또는 클래스에서만 사용 가능
- public
  - 어디서든 접근 가능, 함수 또는 클래스 앞에 아무 접근자도 붙이지 않으면 자동으로 기본 지정되어서 따로 명시할 필요 없음
- protected
  - 상속받는 인터페이스, 클래스 또는 자식 클래스에서만 접근 가능
- internal
  - 같은 모듈 안에서는 다 접근 가능

#### Mutable과 Immutable 의미 및 존재 이유 설명

- 코틀린 콜렉션에서 제공하는 2가지 타입의 인터페이스
- 변경 가능 여부에 따라 2가지로 구분
- 코틀린은 불변성을 권장
- 불변성이 중요한 함수형 프로그래밍을 돕기 위해 사용

#### 코틀린 장점 설명

- 기존의 자바 코드의 보일러 플레이트 구문 최소화 가능
- 자바 8 / RxJava / 람다 등의 활용을 통해 코드 간소화가 가능하나 라이브러리들의 의존성문제와 기존 라이브러리에 대한 학습등이 부담으로 다가오는 문제점 존재
- NullPointerException 핸들링
- 보일러 플레이트 개선 (데이터 클래스 등)
- Collections에 filter, map, foreach 같은 고차함수를 적용 가능
- 변경 가능한 컬렉션과 불가능한 컬렉션을 엄격히 구분
- 서버에서 수신받은 데이터를 컬렉션으로 다룰 일이 많기때문에 코드를 보다 간결하고, 안전하게 만드는 데 도움이 됨 - 확장함수(이미 존재하는 클래스에 새로운 함수를 추가)라는 기능 제공
- 자바와 호환성이 무척 좋고 기존의 라이브러리를 제약없이 사용 가능

#### 코틀린 inline 함수 / 클래스 설명 (스터디 및 추가 정리 필요)

- 자바에서는 제공하지 않음
- 람다식 사용 시 무의미한 객체 생성 방지
- 람다식 내 로컬 변수 추가되는 것에 대한 개선
- public inline 함수는 private 함수 호출 불가능
- 참고. 람다의 경우 컴파일 단계에서 파라미터 개수에 따라 Function 형태의 인터페이스로 변환됨
- inline 키워드를 사용하면 함수를 호출하는 모든 문장을 함수 본문에 해당하는 바이트코드로 바꿔주기 때문에 오버헤드를 감소시킴

#### 코틀린 확장함수 (Extension Function)

- 클래스에는 다양한 매소드(함수)들이 존재하는데, 이때 기존의 클래스에 내가 원하는 새로운 함수를 추가(확장)하려고 할 때 사용하는 함수
- 기존의 클래스에 새로운 함수를 확장한다라는 의미
- 만약 모든 클래스에 내가 만든 확장함수를 추가하고 싶다면 최상위 클래스인 'Any'에 확장 함수를 구현하면 가능
- 코틀린의 최상위 요소는 'Any'이기 때문에 Any에 확장 함수를 추가하면 코틀린의 모든 요소에 상속되기 때문에 모든 클래스에 내가 만든 확장함수를 추가 가능
- 개발 시 확장함수를 잘 설계해서 정의해놓으면 효율적인 코드 작성 가능

#### 코루틴 정리

- co : with, together 
- routine : 규칙적으로 하는일의 통상적인 순서와 방법
- coroutine : co + routine의 합성어로 협동루틴
- 즉, 코루틴이란 함께 동작하면서 규칙이 있는 일의 순서를 의미
- 코루틴은 실행이 마지막으로 중단되었던 지점의 바로 다음장소에서 실행을 재개
- 동기는 launch, 비동기는 async로 표현
  - Builder: launch, async, 코루틴을 실행하는 함수
- Main: 메인 스레드. 화면 UI 작업 등을 하는 곳
- IO: 네트워크, DB 등 백그라운드에서 필요한 작업을 하는 곳
- Default: 정렬이나 무거운 계산 작업 등을 하는 곳
- Coroutines simplify async code by replcaing callbacks
- 구글에서는 코루틴을 비동기처리에서 쓰면 코드를 간단하게 작성할 수 있다고 함
- 코루틴이 메인스레드가 blocking되는 부분에 대해서도 도움을 주고 비동기 처리코드를 순차적인 코드로 만들수 있게 해줌
- delay는 no blocking, sleep은 blocking 함수
- CoroutineScope: 코루틴을 제어할 수 있는 범위
- CoroutineContext: 코루틴이 실행될 Context, 코루틴의 실행 목적에 맞게 실행될 특정 스레드풀을 지정



