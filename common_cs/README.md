#### 블로킹, 논블로킹, 동기, 비동기에 대한 설명

- 블로킹, 논블로킹: A 함수가 B 함수를 호출했을 때 **제어권을 어떻게 처리하느냐에** 따라 달라진다.
  - **블로킹**: A 함수가 B 함수를 호출하면, 제어권을 A가 호출한 B함수에 넘겨준다.
  - **논블로킹**: A 함수가 B 함수를 호출해도 제어권은 그대로 자신이 가지고 있음.
- 동기, 비동기: 호출되는 **함수의 작업 완료 여부를 신경쓰는지**의 여부 차이
  - **동기**: 함수 B의 리턴값을 계속 확인하면서 신경쓰는 것
  - **비동기**: 함수 A가 B를 호출할 때 콜백 함수를 함께 전달, 함수 B의 작업이 완료되면 콜백 함수를 실행. 함수 A는 B를 호출한 이후로 함수 B의 작업 완료 여부에는 신경쓰지 않음.
- **Sync Blocking**
  - 함수는 다른 함수의 리턴값을 고려해서 동작 (동기)
  - 함수는 다른 함수에게 제어권을 넘겨주고 대기 (블로킹)
- **Sync NonBlocking**
- **Async-NonBlocking**
- **Async-blodking**

#### 동기와 비동기의 차이

- 동기(Synchronous) 방식
  - 요청을 보내고 실행이 끝나면 다음 동작을 처리하는 방식
  - 순서에 맞추어 진행되기 때문에 제어 쉬움
  - 여러가지 요청을 동시에 처리할 수 없어 효율 낮음
  - Ex. 콜센터 종업원이 일을 처리하는 방식. 콜센터의 직원은 한 손님의 전화 응대가 끝난 후에 다음 손님의 응대를 진행 가능
- 비동기(Asynchronous) 방식
  - 요청을 보내고 해당 동작의 처리 여부와 상관없이 다음 요청이 동작하는 방식
  - 작업이 완료되는 시간을 기다릴 필요가 없기 때문에 자원을 효율적으로 사용 가능
  - 작업이 완료된 결과를 제어하기 어려움
  - Ex. 이메일. 우리는 한 사람에게 이메일을 보냈을 때 답변을 받지 않고도 이메일을 다시 보내는 것이 가능

#### 컴퓨터 구조 설명

- 컴퓨터
  - [하드웨어]
    - 중앙처리장치
      - 연산 장치
      - 제어 장치
    - 기억장치
      - 주기억 장치
      - 보조기억장치
    - 입출력장치
  - [소프트웨어]
    - 시스템 (하드웨어 제어 / 관리)
      - 펌웨어, 운영체제, 컴파일러, 장치 드라이버 (저수준 언어)
    - 응용 (일반 사용자 작업 수행 도움)
      - 앱 (고수준 언어)

#### 하드웨어 구성요소 설명

- CPU
  - ALU (Arithmetic Login Unit)
  - Register
    - ALU <--> Register 서로 데이터 주고 받음
  - Control Unit
  - Bus Interface
- Main Memory
- Etc
  - Keyboard / Monitor / Network Card / Hard Disk

#### 기억장치 설명

- 속도 순서
  - 보조기억장치 < 메인메모리 (DRAM) < 캐시메모리 (SRAM) < 레지스터

#### 메인 보드 설명

- 다양한 물리적인 장치를 장착할 수 있는 인쇄회로기판 (PCB)
- 부품에 대한 인터페이스 제공
- 마더보드 = 메인보드

#### GPU 설명

- Graphics Processing Unit
- 그래픽 연산을 빠르게 처리하는 답을 도출하는 연산 장치
- 인공지능, 고화질 게임, 무인 자동차 등에 주로 사용
- 대규모 행렬 / 벡터 연산 처리에 탁월

#### 보조 기억 장치 설명

- 메인 메모리보다 속도 느림
- 전원 차단되어도 내용 유지 / 저장 용량 큼
- 종류
  - 하드 디스크
  - SSD (전력 소비 적음, 사용 수명이 HDD 에 비해 상대적으로 낮음)

#### 메모리 설명

- 컴퓨터에서 작업을 수행하기 위해 처리 대상이나 결과 등을 저장하기 위한 공간
- 프로그램을 실행하기 위한 정보들은 메모리에 저장되어 처리됨.

#### 메인 메모리 설명

- [주기억장치]
- RAM (Random Access Memory)
- 전원이 사라이면 저장 내용 사라짐 (휘발성)
- 프로그램 실행 시 프로그램은 메인 메모리에 적재 (프로세스 형태)
- CPU 는 메인 메모리에 적재된 프로그램 명령 코드를 읽어 들여 실행 / 처리

#### CPU 설명

- Central Processing Unit
- 인간의 뇌와 같은 역할 수행
- 연산 + 제어 담당
- ALU 연산 장치 사용
- 메인 메모리에서 명령어를 읽어, 계산한 뒤에 메인 메모리에 저장
- 모듈 (서로 내부적인 버스로 연결)
  - [산술/논리] 장치 (ALU)
    - 가장 빠른 연산 장치
    - 연산 처리
  - [제어장치] (Control Unit)
    - 메인 메모리에 적재된 처리해야 될 데이터 해석 / 제어 신호 생성
    - ALU에게 연산 수행 명령
    - 메인 메모리에 대한 읽기 / 쓰기 등의 제어 명령 내림
  - [레지스터]
    - 임시적으로 데이터를 담을 수 있는 장소
    - CPU의 현재 상태를 저장
    - 실제 연산은 CPU 내부에서 처리 되므로 필요한 데이터를 저장

#### 프로그램 수행 절차 설명

- 1. 프로그램 실행
- 2. 보조 기억 장치 내 프로그램이 메인 메모리로 적재
- 3. 프로그램의 코드 영역의 명령어를 읽어 명령 수행
- 4. 명령어 인출 / 해석 / 실행 사이클 반복
  - fetch: 메인 메모리에서 수행할 명령어를 레지스터로 가져옴
  - decode: 명령어 정보 해석
  - execute: 제어 장치가 명령어 수행을 위한 적절한 제어 신호를 보내 실행

#### 캐시 메모리 설명

- 빠른 CPU와 상대적으로 느린 메인 메모리 사이 위치
- 두 장치 속도 차이에서 오는 병목 현상을 보상/완화 하기 위해 사용
- Main Memory <--> Level3 <--> L2 <--> L1 <--> CPU
- 메인 메모리에서 CPU로 적재할 데이터를 레지스터에 적재하기 전 캐시에 보관
- 데이터 접근 시 캐시 메모리에서 먼저 데이터 검색
- 캐시 히트
  - 원하는 데이터를 찾은 것
  - 데이터를 찾은 경우 메인 메모리에 접근하지 않아도 되므로 시간 효율적
- 기본 동작 과정
  - 데이터를 메인 메모리에서 캐시로 복사
  - 캐시에서 데이터를 꺼낸 뒤에 CPU가 처리
  - CPU는 데이터 접근이 필요한 경우 캐시 메모리를 먼저 검사 / 가져옴
  - 캐시에 데이터 없는 경우 메인 메모리에서 캐시 메모리로 해당 데이터 복사

#### CPU의 메모리 I/O 도중 생기는 병목 현상 해결 방법

- 메모리의 계층화를 통한 현상 해결
- 자주 접근하는 데이터의 경우에는 캐시 메모리에 저장하여 접근 속도를 향상 시킴으로서 부하를 감소

#### 가상 메모리와 페이지 폴트 설명

- **가상메모리**
  - RAM 의 부족한 용량 보완을 위해 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식
  - OS는 프로세스들의 내용 (페이지) 중에서 덜 중요한 것들을 HDD로 옮겨 놓고, 관련 정보를 페이지 테이블에 기록
- **페이지폴트**
  - CPU는 프로세스를 실행하면서 페이지 테이블을 통해 페이지를 조회하는데 실제 메모리에 원하는 페이지가 없는 상황이 발생하는 것 (Valid Bit를 통해 확인)
  - 실제 메모리에 필요한 데이터(페이지)가 없으면 가상메모리를 통해 해당 데이터를 가져오게 되는데 가상메모리는 HDD에 저장되어 있기 때문에 페이지 폴트 발생하면 I/O에 의한 속도 저하가 발생함

#### 페이지 교체 알고리즘과 LRU (Least Recently Used) 설명

- **LRU**
  - Least Recently Used, 페이지를 교체하기 위한 알고리즘 중 하나
  - 실제 메모리의 페이지들 중에서 가장 오랫동안 사용되지 않은 페이지를 선택하는 방식
- **페이지-교체**에 대한 설명
  - 교체 이유는 가상메모리를 통해 조회한 페이지는 다시 사용될 가능성이 높기 때문임
  - 교체를 위해서는 실제 메모리에 존재하는 페이지를 가상 메모리로 저장한 후에, 가상 메모리에서 조회한 페이지를 실제 메모리로 로드해야 함
  - 이 과정에서 어떤 실제 메모리의 페이지를 가상 메모리로 희생시킬 것이냐에 대한 문제가 발생하는데 이때 사용하는 알고리즘 중 하나가 LRU 알고리즘
- 그 외 알고리즘 정보
  - 먼저 적재된 페이지를 희생시키는 FIFO 알고리즘
  - LRU 알고리즘 응용하여 페이지에 Second-Change를 주는 LRU Approximation 등이 존재

#### 웹 캐시 설명

- Web Cache
- 웹 브라우저의 경우 자주 방문하는 웹 사이트에 대해 자주 쓰이는 데이터를 저장
- 웹 데이터를 캐시 처리 => 웹 캐시
- 자주 접속하는 사이트의 이미지, HTML 등에 대해 특정 저장 공간에 저장

#### 노트북 (Laptop) 특징 설명

- 휴대용
- 모니터, 키보드, 카메라, 메인보드, CPU, 그래픽 카드 등이 한꺼번에 탑재
- 편리하여 수요 높음

#### 프로세스와 스레드 차이점

- 참고. 프로그램: 어떤 작업을 위해 실행할 수 있는 파일
- 프로세스
  - 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
  - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스 (독립적인 개체)
  - 운영체제로부터 시스템 자원을 할당받는 작업 단위
    - CPU 시간 / 운영에 필요한 주소 공간 / 코드-데이터-스택-힙의 구조로 되어 있는 독립된 메모리 영역
  - 실행된 프로그램
  - 프로세스는 운영체제로부터 각각 독립된 메모리 영역을 할당받음
  - 최소 1개의 스레드 (메인 스레드)를 가지고 있음
  - 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근 불가능
  - 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신 필요
    - IPC : Inter-Process Communication
    - Ex. 파이프, 파일, 소켓 등을 이용한 통신 방법 이용
- 스레드
  - 프로세스 내에서 실행되는 여러 흐름의 단위
  - 프로세스의 특정한 수행 경로
  - 프로세스가 할당받은 자원을 이용하여 동작하는 실행 단위
  - 스레드는 각각 스택만 따로 할당받고 나머지 메모리 영역인 코드, 데이터, 힙 영역은 공유
    - 스택 분리 이유: 스택에는 함수 호출 정보가 저장되는데 스택을 공유하면 LIFO 구조에 의해 실행 순서가 복잡해지기 때문에 실행 흐름을 원활하게 만들기 위한 목적
  - 프로세스 내의 주소 공간이나 자원을 같은 프로세스 내 스레드끼리 공유하면서 실행
  - 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간 공유
  - 별도의 레지스터와 스택 가지고 있음
  - 프로세스의 자원을 서로 공유하기 때문에 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드도 그 변경 결과를 즉시 볼 수 있음
  - 자바 스레드 (Java Thread)
    - JVM이 운영체제의 역할, 나머지는 일반 스레드와 동일
    - 자바에는 프로세스는 존재 X, 스레드만 존재
    - JVM에 의해 스케쥴되는 실행 단위 코드 블록
    - 스레드 스케쥴링은 전적으로 JVM에 의해 이루어짐
    - JVM 이 관리하는 항목
      - 스레드 개수
      - 스레드로 실행되는 프로그램 코드의 메모리 위치
      - 스레드 상태
      - 스레드 우선순위
    - 개발자는 스레드 코드 작성 후 그 코드가 실행을 시작하도록 JVM에 요청하는 일을 하는 것

#### 멀티 프로세스와 멀티 스레드의 차이

- 멀티 프로세스
  - 멀티 프로세싱
    - 하나의 응용 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(Task)을 처리하도록 하는 것
  - 여러 개 프로세스 중 하나에 문제가 생겨도 전체 흐름에 영향 없음
  - 단점
    - Context Switching 에서의 오버헤드
      - Context Switching: CPU에서 여러 프로세스를 돌아가면서 작업 처리하는 과정
      - 캐쉬 메모리 초기화 / 인터럽트 등의 무거운 작업 진행 및 많은 시간 소요
      - 프로세스 특성 상 서로 공유하는 메모리가 없고 각각 독립적인 메모리를 할당받았기 때문에 컨텍스트 스위칭이 발생하면 캐쉬에 있는 모든 데이터를 리셋하고 다시 데이터를 불러와야 하는 문제 있음
      - CPU 레지스터 교체 / RAM, CPU 사이 캐쉬 메모리 데이터 초기화
- 멀티 스레드
  - 하나의 응용 프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것
  - 웹 서버는 대표적인 멀티 스레드 프로그램
  - 장점
    - 시스템 자원 소모 감소 (효율성 증대)
      - 프로세스 생성 후 자원 할당을 위한 시스템 콜이나 컨텍스트 스위칭 오버헤드가 줄어들어 자원을 효율적으로 관리 가능
    - 시스템 처리량 증가 (처리 비용 감소)
      - 데이터 공유가 간단, 자원 소모 감소
      - 작업량이 작아 컨텍스트 스위칭이 빠름
    - 간단한 통신 방법으로 인한 응답 시간 단축
      - 스택을 제외한 나머지 모든 메모리 영역을 공유하기 때문에
  - 단점
    - 설계 주의
    - 어려운 디버깅
    - 단일 프로세스 시스템의 경우 효과를 기대하기 어려움
    - 다른 프로세스에서 스레드 제어 불가능
    - 자원 공유의 문제 발생 (동기화)
      - 전역 변수 (데이터 세그먼트) 이용한 자원 공유가 이루어지므로 함께 사용 시 동기화 문제 발생 가능성 (여러 쓰레드가 하나의 자원에 동시에 접근하는 경우)
    - 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향 받음

#### 데드락(DeadLock) 설명

- 데드락(DeadLock) 또는 교착상태란 한정된 자원을 여러 프로세스가 사용하고자 할 때 발생하는 상황
- 프로레스가 자원을 얻기 위해 영구적으로 기다리는 상태
- Ex. 데드락 발생 상황
  - 자원 A를 가진 프로세스 P1과 자원 B를 가진 프로세스 P2가 있을 때, P1은 B를 필요로 하고 P2는 A를 필요로 한다면 두 프로세스 P1, P2는 서로 자원을 얻기위해 무한정 기다리게 됨

#### 세마포어(Semaphore)와 뮤텍스(Mutex) 차이

- **뮤텍스**
  - Locking 메커니즘으로 Lock을 걸은 쓰레드만이 임계 영역을 나갈때 락을 해제 가능
  - 1개의 락만을 갖는 Locking 메커니즘
  - Locking 메커니즘으로 오직 하나의 쓰레드만이 동일한 시점에 뮤텍스를 얻어 임계 영역(Critical Section)에 들어올 수 있음
  - 그리고 오직 이 쓰레드만이 임계 영역에서 나갈 때 뮤텍스를 해제 가능
- **세마포어**
  - Signaling 메커니즘으로 Lock을 걸지 않은 쓰레드도 Signal을 사용해 락 해제 가능
  - 세마포어의 카운트를 1로 설정하면 뮤텍스처럼 활용 가능 (아래에서 추가 설명)
  - 세마포어는 동기화를 위해 wait와 signal이라는 2개의 atomic operations를 사용
  - wait를 호출하면 세마포어의 카운트를 1줄이고, 세마포어의 카운트가 0보다 작거나 같아질 경우에 락이 실행
  - 세마포어의 카운트가 0보다 작거나 같아져 동기화가 실행된 상황에, 다른 쓰레드가 signal 함수를 호출하면 세마포어의 카운트가 1증가하고, 해당 쓰레드는 락에서 나올 수 있음
  - 세마포어는 크게 Counting Semaphores, Binary Semaphore 2종류
  - 카운팅 세마포어는 세마포어의 카운트가 양의 정수값을 가지며, 설정한 값만큼 쓰레드를 허용하고 그 이상의 쓰레드가 자원에 접근하면 락이 실행
  - 바이너리 세마포어는 세마포어의 카운트가 1이며 Mutex처럼 사용 가능(뮤텍스는 절대로 세마포어처럼 사용 불가능)

#### 프로토콜 설명

- 서로 다른 시스템에 있는 개체 간에 데이터를 전송하는 통신 규약
- 7계층 구조로 정의 / 각 층마다 역할이 구분

#### OSI 7계층 설명

- 네트워크 상에서 통신이 수행되는 과정을 7단계로 표현
  - 국제표준화기구(ISO) 참여 / 개발
- 전체 과정이 구분된다는 점에서 문제가 생겼을 때 해결 수월함
  - 이상 발생 계층의 장비만 수리 가능, 효과적
- 7 계층 레이어
  - 7. **응용** (Application): HTTP, FTP 프로토콜 활용
    - 사용자와 직접 상호작용하는 응용 프로그램들이 포함된 계층
  - 6. **표현** (Presentation): 데이터의 형식 처리 (이미지, 텍스트)
    - 데이터의 형식(Format)을 정의하는 계층
  - 5. **세션** (Session): 논리적인 연결 (세션) 형성
    - 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층
  - 4. **전송** (Transport): 포트 번호, 응용 프로그램 간 연결 담당
    - 최종 수신 프로세스로 데이터의 전송을 담당하는 계층
  - 3. **네트워크** (Network): IP 주소, 목적지까지 데이터 전달
    - 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층
  - 2. **데이터링크** (Datalink): MAC 주소, 물리 주소 결정
    - 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당하는 계층
  - 1. **물리** (Physical): 랜선, 통신 케이블, 전기 신호 전달
    - 데이터를 전기 신호로 바꾸어주는 계층
- TCP/IP 계층
  - 4. **응용** (Application): OSI 5, 6, 7 계층
  - 3. **전송** (Transport): OSI 4 계층
  - 2. **인터넷** (Internet): OSI 3 계층
  - 1. **네트워크-인터페이스** (Network Interface): OSI 1, 2 계층

#### TCP 연결 / 해제 과정 설명

- TCP
  - 안전, 정확한 데이터 전송 목표
  - 연결 성립: 3Way Handshake
    - \*3Way Handshake: TCP 네트워크에서 통신을 하는 장치가 서로 연결이 잘 되었는지 확인하는 방법. 송신자와 수신자는 총 3번에 걸쳐 데이터를 주고 받으며 통신이 가능한 상태임을 확인
    - 클라이언트 => 서버, 연결 목적의 SYN(x) 패킷 전송
    - 서버 => 클라이언트, 확인신호 ACK(x+1), SYN(y) 패킷 전송
    - 클라이언트 => 서버, 확인신호 ACK(y+1) 전송
  - 연결 해제: 4Way Handshake
    - 클라이언트 => 서버, FIN_WAIT_1 상태 유지 + FIN 패킷 전송
    - 서버 => 클라이언트, CLOSE_WAIT 상태 유지 + ACK 패킷 전송
    - 서버, 연결 해제 알림 목적의 FIN 패킷 전송
    - 클라이언트 => 서버, TIME_WAIT 상태 유지 + ACK 패킷 전송
    - TIME_WAIT 시간 만료되면 클라이언트 소켓 닫음

#### TCP/IP 흐름 제어 방법

- 흐름 제어
  - Stop And Wait
  - Sliding Window
- 혼잡 제어
  - AIMD (Additive Increase / Miltiplicative Decrease)
  - Slow Start
  - Fast Recovery

#### TCP와 UDP 통신에 대한 설명

- TCP (Transmission Control Protocol)
  - 연결 지향형
  - 가상 회선 방식
  - 1:1 통신
  - 신뢰 가능한 데이터 전송 지원 프로토콜
  - 3-Way Handshaking 방식 / 연결 해제는 4-Way
  - 패킷의 순서 보장
  - UDP에 비해 상대적으로 전송 속도 느림
  - 흐름 제어: 송신/수신 측의 데이터 처리 속도 차이 조절
  - 혼잡 제어: 패킷 수로 인한 네트워크 Overflow 발생 가능성 조절
  - 수신가능? => 네 => 데이터 보내요 이제 => 데이터 잘 갔나요? => 네
    - 수신 여부 확인
- UDP (User Datagram Protocol)
  - 비연결형, 비신뢰성
  - 데이터그램 방식
  - 1:1, 1:N, N:N 통신
  - 데이터의 경계 구분
  - 패킷 부가적 정보가 적어 (오버헤드 적음) 네트워크 부하 감소
  - 일방적인 데이터 전달
  - 연결 과정 없음, 혼잡제어 과정 없음
  - TCP 보다 속도 빠름
  - 게임 / 실시간 동영상 / 음성 스트리밍에서 주로 사용
  - 데이터 보내요 => 데이터 보내요 => ...

#### 슈퍼키, 후보키, 기본키, 외래키 설명

- 공통: 고유한 식별자 (Identifier)
- 키: 데이터베이스에서 조건에 만족하는 관계의 행을 찾거나 순서대로 정렬할 때 다른 행과 구별할 수 있는 유리한 기준이 되는 속성의 집합
- 종류
  - 슈퍼키
    - 각 행을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합
    - 유일성만 만족하면 가능
      - 하나의 키로 특정 행을 바로 찾아낼 수 있는 고유한 데이터 속성
    - Ex. 주민번호 / 이름 + 나이
  - 후보키
    - 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합
    - 유일성과 최소성 둘 다 만족
  - 기본키
    - 후보키 중에서 하나를 선택한 키
    - 유일성과 최소성 둘 다 만족
    - 오직 1개 지정 가능
    - NULL 값 가질 수 없고 중복된 값 가지는 것이 불가능
  - 대체키
    - 기본키로 지정하고 남은 후보키
  - 외래키
    - 두 개의 테이블을 연결해주는 연결 다리 역할

#### 데이터베이스 정규화와 비정규화의 차이

- 정규화 (Normalization)
  - 데이터 중복 최소화 / 일관성 최대화하도록 설계하는 것
  - 데이터를 분해하는 과정
  - 이상현상 (Anomaly) 방지
    - 삽입 이상
    - 삭제 이상
    - 수정 이상
  - 제 1정규화 (1NF)
  - 제 2정규화
  - 제 3정규화
  - BCNF 정규화
  - 제 4 정규화
  - 제 5 정규화
- 비정규화 (반정규화, Denormalization)
  - 읽는 시간을 최적화하도록 설계하는 것
  - 의도적으로 정규화 원칙을 위배하는 행위

#### 데이터베이스 조인 설명

- 한 데이터베이스 내의 여러 테이블의 레코드를 조합하여 하나의 열로 표현하는 것
- 테이블로서 저장되거나 그 자체로 이용할 수 있는 결과 셋을 생성
- 둘 이상의 테이블을 연결해서 테이블을 검색하는 방법

#### 데이터베이스 식별, 비식별 관계 개념 설명

- 식별 관계
  - 부모 테이블의 기본키 또는 유니크 키를 자식 테이블이 자신의 기본키로 사용하는 관계
- 비식별 관계
  - 부모 테이블의 기본키 또는 유니크 키를 자신의 기본키로 사용하지 않고, 외래 키로 사용하는 관계

#### 트랜잭션 설명

- 병행 제어 / 회복 작업 시 처리되는 작업의 논리 단위
- 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위
- 하나의 작업 단위
- 필요한 작은 단위의 코드 위주로 트랜잭션 사용 권장
- 만족시켜야 할 특성
  - 원자성
  - 일관성
  - 격리성
  - 지속성
- Commit
- Rollback
- 상태 전이
  - 활동
  - 부분 완료
  - 완료
  - 실패
  - 취소

#### DBMS 설명

- 데이터베이스에 존재하는 데이터에 접근할 수 있도록 해주는 소프트웨어
- 자바 기반 서버 프로그램에서는 JDBC를 이용해 MySQL에 접근 가능
  - JDBC: Java DataBase Connectivity
- DBMS 를 다루기 위해서는 SQL 이해 필수
  - SQL: Structured Query Language
  - DBMS에 존재하는 데이터 관리를 위한 프로그래밍 언어

#### 관계형 데이터베이스 설명

- RDBMS
- 행과 열이 존재하는 하나이상의 테이블 (릴레이션)
  - 행 = 레코드 = 튜플
  - 열 = 필드 = 속성
- 관계 = 테이블 (같은 속성을 지닌 튜플의 모임)
- Ex. Oracle / MySQL / MSSQL
- 테이블에 따라서 데이터가 분리 / 중복 적음
- 여러 개의 테이블로 구성
- 두 테이블에 대해 특정 키를 기준으로 데이터 조회 가능
  - Primary Key / Foreign Key

#### 테이블 컬럼 컨벤션 설명

- 테이블 이름은 단수형 사용
- 명명 방법은 스네이크 케이스 사용
- 테이블의 키는 "테이블이름\_id" 또는 id

#### 컨텍스트 스위칭 개념

- CPU 에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정
- 인터럽트를 발생시켜 CPU에서 실행 중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정
  - \*인터럽트: CPU가 프로세스를 실행하고 있을 때, 입출력 HW 등의 장치나 예외 상황이 발생하여 처리가 필요함을 CPU에게 알리는 것 의미
- 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태 (Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업
- 스위칭 시 CPU 레지스터 교체 / RAM, CPU 사이의 캐쉬 메모리 데이터 초기화

#### 프로세스 제어 블록

- Process Control Block, PCB
- 프로세스에 대한 중요한 정보를 저장하고 있는 OS의 자료구조
- OS는 프로세스 관리를 위해 프로세스의 생성과 동시에 고유한 PCB를 생성
- 저장되는 정보
  - PID
  - 프로세스 상태
  - 프로그램 카운터 (다음에 실행할 명령어의 주소)
  - CPU 레지스터
  - CPU 스케쥴링 정보 (우선순위, 스케쥴 큐에 대한 포인터)
  - 메모리 관리 정보
  - 입출력 관리 정보 (할당된 입출력 장치들과 열린 파일 목록)
  - 어카운팅 정보 (사용된 CPU 시간, 시간제한, 계정번호)

#### RESTful API 설명

- HTTP 프로토콜을 기반으로 하는 웹 서비스 아키텍쳐
- 자원, 메소드, 메시지 등을 정의하여 클라이언트-서버 간의 통신을 가능케 함
- 표준 HTTP 메소드(GET, POST, PUT, DELETE)를 사용하여 서버와 통신
- 웹 상에 존재하는 모든 자원에 URI (test.co.kr)를 부여하여 사용하는 방법
- 비연결성, URI로 자원에 접근
- HTTP 웹 표준을 이용하며 HTTP 캐싱 활용이 가능하다는 장점
- 구조의 명확성 증대 => 서버, 클라이언트에서 개발해야 될 부분이 명확해짐
- URI만 봐도 어떤 요청인지 파악 가능할 정도로 직관적
- REST(REpresentational State Transfer)ful API는 HTTP 통신에서 어떤 자원에 대한 CRUD 요청을 Resource와 Method로 표현하여 특정한 형태로 전달하는 방식
- 구성 요소
  - Resource(자원, URI)
  - Method(요청 방식/메소드, GET or POST 등)
  - Representation of Resource(자원의 형태, JSON or XML 등)

#### RESTful API 에서 POST, PUT 그리고 PATCH 차이점

- POST는 Create(생성), PUT은 Update(수정)에 매칭
- 자원에 대한 생성은 POST가 담당 (리소스의 생성을 담당), 자원에 대한 수정은 PUT이 담당 (리소스의 생성과 수정을 담당)
- PUT은 요청 시마다 같은 리소스를 반환 (리소스 안에 속성은 변경될 수 있음)
- POST는 요청 시마다 새로운 리소스가 생성
- PATCH도 수정을 담당하는 메소드인데 PUT과 다르게 리소스의 일부분만 수정할 때 사용하고 PUT은 리소스의 모든 속성을 수정하기 위해 사용

#### 함수형 프로그래밍 특징 설명

- immutable data와 first class citizen으로서의 함수
- 부수효과가 없는 순수 함수를 이용하여 프로그램을 만드는 것
  - 부수 효과가 없는 순수 함수란 데이터의 값을 변경시키지 않으며 객체의 필드를 설정하는 등의 작업을 하지 않는 함수를 의미

#### 메모리 구조 설명

- 코드 영역: 실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 부름
  - 사용자가 프로그램 실행 명령을 내리면 OS가 HDD에서 메모리로 실행 코드를 올리게 되고, CPU는 코드 영역에 저장된 명령어를 하나씩 처리하게 됨.
- 데이터 영역: 프로그램의 전역 변수(global)와 정적 변수(static)가 저장되는 영역
  - 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸함
- 힙 영역: 프로그래머가 직접 관리할 수 있는 메모리 영역으로 이 공간에 메모리를 할당하는 것을 동적 할당이라 함
  - Java에서는 가비지 컬렉터가 자동으로 해제해줌
  - 힙 영역은 스택 영역과 달리 낮은 주소에서 높은 주소로 메모리가 할당됨
- 스택 영역: 함수의 호출과 함께 할당되며 지역 변수와 매개 변수가 저장되는 영역
  - 스택 영역에 저장되는 함수의 호출 정보를 스택프레임이라고 함
  - 스택 영역은 함수의 호출이 완료되면 소멸
  - 스택 영역은 높은 주소에서 낮은 주소로 메모리가 할당

#### 프레임워크와 라이브러리 차이

- 라이브러리: 사용자가 흐름에 대한 제어를 하며 필요한 상황에 가져다가 쓸 수 있음
- 프레임워크: 전체적인 흐름을 자체적으로 제어함
- 추가 설명
  - 프레임워크와 라이브러리는 실행 흐름에 대한 제어 권한이 어디 있는지에 따라 달라짐
  - 프레임워크를 사용하면 사용자가 관리해야 하는 부분을 프레임워크에 넘김으로써 신경써야 할 것을 줄이는 제어의 역전(IoC, Inversion Of Control)이 적용됨

#### 병렬 처리 프레임워크의 종류와 특징

- Hadoop
  - HDFS(Hadoop Distributed File System)를 활용해 데이터를 주고 받음
  - 데이터가 여러 노드에 분산되어 저장되기 때문에 손실의 우려가 없다는 장점이 있음
    - File I/O를 기반으로 작동하기 때문에 처리 속도가 느림
- Spark
  - In-Memory 상에서 데이터를 주고받고 연산을 수행
  - 메모리를 사용해 데이터를 처리하기 때문에 Hadoop보다 속도가 약 100배 정도 빠름
    - 메모리상에서 처리하기 때문에 장애가 발생한 경우 응용 프로그램을 처음부터 다시 시작해야 하는 단점이 있음

#### Call By Value와 Call By Reference 차이

- Call By Value
  - 인자로 받은 값을 복사하여 처리하는 방식
  - Call By Value에 의해 넘어온 값을 증가시켜도 원래의 값이 보존됨
  - 값을 복사하여 넘기기 때문에 메모리 사용량이 늘어남
  - 함수가 호출될 떄, 메모리 공간 안에서는 함수를 위한 별도의 임시공간이 생성되는데 call by value 호출 방식은 전달되는 변수 값을 복사해서 함수 인자로 전달
  - 인자를 넘겨줄 때 마다 메모리 공간을 할당해야 하기 때문에 공간의 낭비가 일어날 가능성 있음
  - 함수 안에서 인자 값이 변경되더라도, 외부 변수 값은 변경되지 않음
- Call By Reference
  - 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 주는 방식
  - 값을 복사하지 않고 직접 참조하기 때문에 속도가 빠름
  - 원래의 값에 영향을 주는 리스크 존재
  - 함수 호출 시 인자로 전달되는 변수 값이 아닌 주소(Address)를 넘겨줌으로써, 주소를 참조(Reference)하여 데이터를 변경 가능
  - 함수 안에서 인자 값이 변경되면 전달된 객체의 값도 변경됨
- Java 호출 방식은 함수에 전달되는 인자의 데이터 타입에 따라 함수 호출 방식이 다름
- primitive type(원시 자료형)은 call by value 호출 방식을 사용 (자료형에는 int, short, long, float, double, char, boolean이 있음) 
- reference type(참조 자료형)은 call by reference 호출 방식이며 자료형에는 array, Class instance, String이 있음 
  - String은 약간 특이한데, 참조 자료형이지만 Java에서 동작할 때는 원시 자료형처럼 적용됩니다.

#### 메세지 큐(Message Queue) 설명

- Queue 자료구조를 이용하여 데이터(메세지)를 관리하는 시스템
- 비동기 통신 프로토콜을 제공하여 메세지를 빠르게 주고 받을 수 있게 해줌
- Producer(생산자)가 Message를 Queue에 넣어두면, Consumer가 Message를 가져와 처리
  - 생산자는 메세지를 큐에 쌓고 소비자는 메세지를 꺼내어 처리
- 대표적 시스템 예: Kafka, Rabbit MQ, AMPQ 등

#### Docker(도커)와 Kubernates(쿠버네티스) 설명

- Docker는 컨테이너 기반의 가상화 기술
- 기존에는 하드웨어를 가상화하였기 때문에 Host OS 위에 Guest OS를 설치해야 되서 무겁고 느려 한계가 많이 존재
- 이를 극복하고자 프로세스를 격리시킨 컨테이너를 통해 가상화를 하는 Docker(도커)와 같은 기술들이 등장
- 도커를 통해 구동되는 컨테이너를 관리하기 위한 Kubernates(쿠버네티스)가 등장
- 쿠버네티스는 도커 컨테이너를 관리하기 위한 기술

#### Docker(도커)의 장/단점 설명

- 장점
  - 쉽고 빠른 실행 환경 구축
  - 하드웨어 자원 절감
  - Docker Hub와 같은 공유 환경 제공
- 단점
  - 개발 초기의 오버헤드 / 러닝커브
  - Linux 친화적

#### TDD(Test-Driven Development) 설명

- 매우 짧은 개발 사이클의 반복에 의존하는 개발 프로세스
- 개발자는 우선 요구되는 기능에 대한 테스트케이스를 작성하고, 그에 맞는 코드를 작성하여 테스트를 통과한 후에 상황에 맞게 리팩토링하는 테스트 주도 개발 방식
- 개발자는 테스트를 작성하기 위해 해당 기능의 요구사항을 확실히 이해해야 함
- TDD 개발 방식은 개발자가 개발 전에 요구사항에 집중할 수 있도록 도와주지만 테스트를 위한 진입 장벽과 작성해야 하는 코드의 증가는 단점, 적당한 절충안이 필요
  - TDD 베이스로 업무를 진행하되 요구사항 기능을 줄일려고 노력하거나 테스트 코드 작성의 경계치를 설정하는 방향으로 절충 시도

#### DDD(Domain-Driven Design) 설명

- 실세계에서 사건이 발생하는 집합인 Domain(도메인)을 중심으로 설계하는 방법
- 옷 쇼핑몰을 예로 들면 손님들이 주문하는 도메인, 점주들이 관리하는 도메인 등이 있을 수 있는데 이러한 도메인들이 서로 상호작용하며 설계하는 것이 도메인 주도 설계
- 도메인 주도 설계에서 도메인은 각각 분리되어 있는데, 이러한 관점에서 MSA(MicroService Architecture)를 적용하면 용이한 설계가 가능
- DDD에서는 같은 객체들이 존재할 수 있는데, 예를 들어 옷 구매자의 입장에서는 (name, price)와 같은 객체 정보를 담지만, 판매자의 입장에서는(madeTie, size, madeCountry) 등이 있을 수 있음. 즉, 문맥에 따라 객체의 역할이 바뀔 수 있는 것이 DDD

#### MSA(Micro Service Architecture) 설명 및 장/단점 나열

- 모든 시스템의 구성요소가 한 프로젝트에 통합되어 있는 Monolithic Architecture(모놀리식 아키텍쳐)의 한계점을 극복하고자 등장
- MSA는 1개의 시스템을 독립적으로 배포가능한 각각의 서비스로 분할
- 각각의 서비스는 API를 통해 데이터를 주고받으며 1개의 큰 서비스를 구성
- 장점
  - 일부 서비스에 장애가 발생하여도 전체 서비스에 장애가 발생하지 않음
  - 각각의 서비스들은 서로 다른 언어와 프레임워크로 구성 가능
  - 서비스의 확장이 용이
- 단점
  - 서비스가 분리되어 있어, 테스팅이나 트랜잭션 처리 등이 어려움
  - 서비스 간에 API로 통신하기 때문에 그에 대한 비용 발생
  - 서비스 간의 호출이 연속적이기 때문에 디버깅 및 에러 트레이싱이 어려움

#### 대칭키 (Symmetric-Key)와 공개키 (Public-Key) 암호화 방식 차이 설명

- 대칭키 암호화 방식
  - 암/복호화에 사용하는 키가 동일한 암호화 방식
  - 대칭키는 암/복호화키가 동일하므로 해당 키를 아는 사람이 문서를 복호화 가능
  - 대표적인 알고리즘: DES, 3DES, AES, SEED, ARIA 등
  - 공개키 암호화 방식에 비해 연산 속도가 빠르다는 장점
  - 키를 교환해야 하는 문제가 발생
  - 키를 교환하는 중 키 탈취 가능성 존재
  - 사용자가 증가할수록 각각의 키가 필요하기에 관리해야 할 키가 방대하게 증가되는 문제 존재
  - 대칭키 단점 보완을 위해 키의 사전 공유, 키 배포 센터 사용, Diffie-Hellman 키 교환, 공개키 암호화 방식 등이 존재
- 공개키 암호화 방식
  - 암복호화에 사용하는 키가 서로 다른 암호화 방식 (비대칭키 암호화)
  - 공개키 암호화 방식은 효율은 떨어지지만, 대칭키 암호화 방식의 키를 교환해야 하는 문제를 해결하기 위해 등장
  - 대표적인 알고리즘: Diffie-Hellman, RSA, DSA, ECC 등
  - A가 B에게 데이터를 보낸다고 할 때, A는 B의 공개키로 데이터를 암호화해서 보내고 B는 본인의 개인키로 해당 암호화된 데이터를 복호화해서 보게 됨
  - 암호화된 데이터는 B의 공개키에 대응되는 개인키를 갖고 있는 B만이 볼수 있음
  - 공개키는 키가 공개되어 있기 때문에 따로 키 교환이나 분배를 할 필요가 없음
  - 중간 공격자가 B의 공개키를 얻는다고 해도 B의 개인키로만 복호화가 가능
  - 키 전달 문제를 해결하여 더 안전하지만, 암호화와 복호화를 위해 복잡한 수학 연산을 수행하기 때문에 대칭키 알고리즘에 비해 속도가 느리다는 단점

#### 함수 설명

- 특정한 목적을 수행하기 위해 독립적으로 짜여진 코드의 집합

#### 웹 동작 방식 설명

- 사용자가 브라우저에 URL을 입력
- 브라우저는 DNS를 통해 서버의 진짜 주소를 찾음
- HTTP 프로토콜을 사용하여 HTTP 요청 메세지를 생성함
- TCP/IP 연결을 통해 HTTP요청이 서버로 전송됨
- 서버는 HTTP 프로토콜을 활용해 HTTP 응답 메세지를 생성함
- TCP/IP 연결을 통해 요청한 컴퓨터로 전송
- 도착한 HTTP 응답 메세지는 웹페이지 데이터로 변환되고, 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 됨

#### 공인 IP와 사설 IP 차이 설명

- 공인 IP
  - 전세계에서 유일한 IP로 ISP(인터넷 서비스 공급자)가 제공하는 IP주소
  - 외부에 공개되어 있기 때문에 인터넷에 연결된 다른 장비로부터 접근이 가능
  - 방화벽 등과 같은 보안 설정을 해주어야 한다.
- 사설 IP
  - 어떤 네트워크 안에서 사용되는 IP주소
  - IPV4의 부족으로 인해 모든 네트워크가 공인 IP를 사용하는 것이 불가능하기 때문에 네트워크 안에서 라우터를 통해 할당받는 가상의 주소
  - 별도의 설정 없이는 외부에서 접근이 불가능

#### 웹 접근성의 국제표준 설명

- 웹 접근성을 높이기 위해 고안된 웹 표준은 웹에서 표준적으로 사용되는 기술이나 규칙을 의미
- 웹 표준을 정하기 위하 W3C(World Wide Web Consortium)이 설립되었으며 웹 표준으로 구조 언어인 HTML, 표현 언어인 CSS, 동작 언어인 Script를 지정

#### 앱 설치를 위한 QR 코드 생성 관련 지식

- 안드로이드 & 아이폰 모두 하나의 QR로 제작 가능
  - 각각 따로 제작하는 것도 가능
  - QR 생성 때 설정 부분에서 Android, iOS 앱 스토어 관련 URL을 각각 설정 가능
- 앱 설치 유무에 따라 앱으로 이동 또는 앱 스토어로 이동하는 기능
  - 불가능
  - 제한적으로는 가능
    - 개발자가 카메라 모듈 기능을 가지고 특정앱을 제작하고 그 특정 앱에서 QR 기능을 커스터마이징 할 수 있으면 가능할 것으로 판단됨.

#### Byte Ordering 설명

- 데이터가 저장되는 순서를 의미
- 빅엔디안(Big Endian)과 리틀엔디안(Little Endian) 방식 존재
- Big Endian
  - MSB (Most Significant Byte)가 가장 낮은 주소에 위치하는 저장 방식
  - 네트워크에서 데이터를 전송할 때 주로 사용됨
  - 가장 낮은 주소에 MSB가 저장되므로, offset=0인 Byte를 보면 양수/음수를 바로 파악 가능
- Little Endian
  - MSB가 가장 높은 주소에 위치하는 방식
  - 마이크로프로세서에서 주로 사용
  - 가장 낮은 주소에 부호값이 아닌 데이터가 먼저 오기 때문에, 바로 연산 가능

#### Fragmentation 설명

- RAM에서 메모리 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 할당/사용이 불가능한 상태
- 내부 단편화
  - 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비 되는 상황
- 외부 단편화
  - 메모리 할당 / 해제 작업이 반복될 때 작은 메모리들이 존재하게 되는데 이 메모리 공간들의 총량은 충분하지만 실제로 할당은 할 수 없는 상황

#### Critical Section 설명

- 동일한 자원을 동시에 접근하는 작업을 실행하는 코드 영역
- 해결을 위한 기본 조건
  - Mutual Exclusion (상호 배제)
    - 프로세스 1이 임계영역에서 실행 중이라면, 다른 프로세스들은 그들이 가진 임계영역에서 실행 불가능
  - Progress (진행)
    - 임계영역에서 실행 중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 임계영역 진입 후보로서 참여 가능
  - Bounded Waiting (한정된 대기)
    - 프로세스 1이 임계영역에 대한 진입 신청 ~ 수락때까지, 다른 프로세스들이 임계영역에 진입하는 횟수는 제한이 있어야 함.

#### Round Robin 설명

- 현대적인 CPU 스케쥴링
- 각 프로세스는 동일한 크기의 할당 시간 (Time Quantum)을 가지게 됨
- 할당 시간이 지나면 프로세스는 선점당하고 Ready Queue의 제일 뒤로 이동
- CPU 사용 시간이 랜덤한 프로세스들이 섞여 있는 경우에 효율적
- RR이 가능한 이유
  - 프로세스의 Context 저장이 가능하기 때문임
- 장점
  - 응답 시간 빨라짐
  - n개의 프로세스가 Ready Queue에 있고 할당 시간이 q(Time Quantum)인 경우 각 프로세스는 q 단위로 CPU 시간의 1/n을 얻음
  - 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않음
  - 프로세스가 기다리는 시간이 CPU를 사용할만큼 증가
  - 모든 프로세스에 대해 공정한 스케쥴링
- 주의점
  - 설정 Time Quantum이 너무 커진다면 FCFS (First Come First Served)와 동일해짐
  - 설정 Time Quantum이 너무 작아지면 알고리즘 목적에는 이상적이나 잦은 컨텍스트 스위칭으로 인한 오버헤드 발생

#### 프록시 서버 기능 설명

- 클라이언트가 프록시 서버를 통해 다른 네트워크 서비스에 간접적으로 접근가능하게 하는 것
- 요청된 내용을 캐시에 저장하고 다음에 같은 요청이 들어왔을 때 캐시 정보를 활용하여 정보를 제공함으로서 전송 시간 감소

#### Base64 설명

- 8비트 바이너리 데이터 (실행 또는 압축 파일 등)를 문자 코드에 영향 받지 않는 공통 ASCII 영역의 문자들로만 이루어진 일련의 스트링으로 바꾸는 인코딩 방식

#### 스테가노그래피 설명

- 전달하려는 메세지의 내용을 이미지 또는 MP3 파일 등의 다른 무언가로 감추어 암호화하여 숨기는 심층 암호 기술

#### 32비트, 64비트 설명

- CPU가 정보를 처리하는 방식, 한번에 처리할 수 있는 명령어의 크기를 의미, CPU의 레지스터 크기
- 명령어가 크다면 명령어를 가져올 때 사용하는 통로의 길이도 크다는 의미 즉, 버스의 데이터 사이즈를 의미
- 32비트
  - 최대 램 4GB (2^32bit => 4GB) 인식
- 64비트
  - 최대 램 512GB
  - 64비트 CPU는 64비트 명령어를 한번에 Fetch 가능
  - 최대 램 512GB 인식
- 프로그램의 크기가 10GB일 경우
  - 32비트의 경우 프로그램 중 4GB만이 적재가 가능하고 64비트 프로세서의 경우 한번에 적재 가능
  - 이러한 이유로 32비트의 경우 메모리 폴트가 이뤄질 수 있으며 메모리 적재과정이 추가적으로 필요하므로 속도가 느려짐
  - 64비트에서는 포인터 크기가 8바이트, 32비트에서는 포인터 크기가 4바이트

#### 버스 (Bus)

- 제어 버스(control bus)
  - 제어장치와 연결된 버스로, CPU가 메모리와 주변장치에 제어 신호를 보냄
  - 메모리와 주변장치에서도 작업이 완료되거나 오류가 발생하면 제어신호를 보내기 때문에 양방향임
- 주소버스(adress bus)
  - 메모리 주소 레지스터(MAR)와 연결된 버스로, 메모리나 주변장치에 데이터를 읽거나 쓸 때 주소 정보를 보냄
  - CPU => 메모리와 I/O 장치로 보내지는 주소정보로, 단방향임
- 데이터 버스(data bus)
  - 메모리 버퍼 레지스터(MBR)와 연결된 버스로, CPU가 메모리나 I/O 장치와 데이터를 주고 받음
  - CPU가 데이터를 읽고 쓸 수 있도록 데이터 이동이 양방향으로 이루어짐

#### 가상메모리

- 실제 메모리가 100퍼센트 사용되지 않는다는것을 알고 효율적인 사용을 위해 실제 메모리 보다 많아 보이게 만드는 기술

#### MMU(Memory Management System)

- CPU가 주소를 접근하려고 할때, 직접 CPU가 가상메모리를 물리메모리로 변환시키는 작업은 비효율적이여서, CPU안의 하드웨어인 MMU가
가상메모리에서 실제 물리 메모리로 변환시켜주는 시스템

#### 페이징 시스템

- 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리주소 정보를 매핑한 표
- 가상주소 v = (p,d)
  - p: 페이지 번호
  - d: 페이지 처음부터 얼마나 떨어진 위치인지
- p' + d 가 실제 물리 주소가 됨
- p' = 최상단 물리주소
- 페이징 단위로 가상주소로 가서 메모리를 가져옴
- 하나의 페이지당 리눅스는 4kb로 나누어져 있음
- 하나의 페이지를 몇개 단위로 잘라놓음
- 페이지는 일관적으로 잘라놓음
- CPU가 데이터를 원할때 랜덤으로 물리 메모리에 데이터를 삽입
- 가상주소와 물리주소는 다름
- 페이지 주소별 프로세스 별로 페이지 테이블 존재
- 물리주소에 없으면 물리 메모리에 업데이트 하고 페이지 테이블에 물리주소를 등록
- 가상페이지의 중간 데이터를 찾을때 제일 가상주소의 최상단의 위치와 몇칸 차이나는지 확인한것을 페이지 테이블에 넣고 물리주소에서 찾을때 물리주소의 최상단에서 몇칸 떨어져있는지를 확인한 값을 가지고 찾음

#### 페이징 시스템과 MMU

- MMU가 제일 처음 하는일
  - 해당 페이지 테이블에 접근
- MMU가 어떻게 해당 페이지의 테이블을 알수 있을까?
  - CR3로 알 수 있음
  - MMU는 CR3로 가서 가상 주소를 가지고 해당 페이지 테이블로 접근

#### APN 

- 요약
  - Access Point Name, 즉 엑세스 포인트 이름. 게이트웨이 이름임
  - 예를 들어 three.co.uk 혹은 lte.sktelecom.com(SK텔레콤) 처럼 도메인 네임으로 쓰일 수도 있고 internet.mnc012.mcc345.gprs 이렇게 형식을 갖춘 하나의 게이트웨이 이름 (게이트웨이가 엑세스 포인트)
- 추가 설명
  - 다른 말로, GSM, GPRS, 3G 혹은 4G mobil network와 다른 컴퓨터 네트워크 사이의 게이트웨이 이름
  - 데이터 연결을 만드는 모바일 디바이스는 통신사에게 제시할 APN을 구성해야 함
   - 이 통신사(carrier)는 이 식별자(identifier)가 어떤 타입의 네트워크 연결로 만들지를 결정
     - 예를 들어 어떤 IP주소를 무선 장치에 할당해야 하는 지, 어떤 보안 방법을 사용해야 하는 지, 그리고 어떻게 또는 어떤 사설 고객 네트워크에 연결해야하는지에 대한 것들 결정
- APN의 구조
  - 2개의 파트로 구성
    - 네트워크 식별자 (Network Identifier) : 외부 네트워크를 정의
    - 사업자 식별자 (Operator Identifier) : 구체적인 사업자의 GGSN에 위치한 PDN(Packet domain network)를 정의
- APN Setting
  - Name : 통신사(carrier)의 이름
  - APN : 위에서 말한 엑세스 포인트 이름, 즉 게이트웨이 이름. (보통 도메인 네임)
  - MCC : Mobile country code. 모바일 국가 코드 (MNC 보단 큰 범)
  - MNC : Mobile Network code. 모바일 네트워크 코드
  - MVNO type(가상 이동통신망 사업자 유형) : MVNO 유형. MVNO는 소위 알뜰폰이라고 불리우는 이동 통신사 (carrier)로부터 통신서비스를 임차해 자사서비스로 운영하는 사업자를 의미함
  - APN type : 이 APN이 지원하는 APN의 유형들

#### HTTP Web Basic Knowledge

- 모든 것이 HTTP 기반 위에서 동작
- 개발 하기 전 HTTP 지식은 필수적

#### 인터넷 네트워크 전체적인 설명

- [인터넷-통신]
  - 클라이언트 <-> 서버
  - 클라이언트 <-> 인터넷 <-> 서버
  - 클라이언트 <-> 거미줄 노드들 <-> 서버
  - 어떻게 수많은 노드들을 거쳐서 목적지까지 가는가?
    - ip, tcp, udp, port, dns 개념 숙지 필요
- [IP-인터넷-프로토콜] (Internet Protocol)
  - 지정한 IP 주소(IP Address)에 데이터 전달
  - 패킷(Packet)이라는 통신 단위로 데이터 전달
  - 메세지를 그냥 보내는 것이 아닌 보내기 위한 패킷 규칙이 존재
    - 출발지(나의 아이피), 목적지 아이피, 전송 데이터 (메세지0) 
  - IP 프로토콜의 한계
    - [비연결성] (패킷 받는 대상이 서비스 불능 상태이라도 하더라도 패킷 전송), 전원 꺼짐 등의 기타 상황, 대상 서버가 패킷을 받을 수 있는 상황인지 아닌지 모름.
    - [비신뢰성] (중간에 패킷이 사라지거나 / 순서대로 오지 않는 문제 - Hello World ==> World Hello 이런식의 문제 발생)
      - 3000바이트짜리 데이터가 있을 때 즉, 패킷 용량이 클때 보통 1500바이트 단위로 쪼개서 보내는데 쪼개서 보낼 때 조금 더 처리가 빠른 노드가 있으면 그 노드로 패킷을 보내기 때문에 1, 2 패킷들이 항상 같은 노드를 거친다고 할 수 없으므로 순서 보장이 어려움
      - 참고. 인터넷 웹은 수많은 노드들로 구성.
    - [프로그램-구분]
      - 같은 IP를 사용하는 서버에서 통신하는 앱이 둘 이상이면?
- [TCP], [UDP]
  - IP 프로토콜의 한계를 극복하기 위해 탄생 (순서 꼬임 / 패킷 소실)
  - [TCP/IP] 패킷 정보
    - 출발지 포트 정보
    - 목적지 포트 정보
    - 전송 제어, 순서, 검증 정보 포함
  - [TCP]
    - 전송 제어 프로토콜 (Transmission Control Protocol)
    - 연결 지향 (TCP 3 way handshake (가상 연결))
      - SYN --> SYN + ACK --> ACK
      - SYN : 접속 요청
      - ACK : 요청 수락
      - 개념적인 연결
    - 데이터 전달 보증 (데이터 전송 -> 데이터 잘 받았다는 응답 송신한다는 의미)
    - 순서 보장 (순서가 잘못 온 경우 다시 보내라고 요청함)
    - 신뢰 가능한 프로토콜
    - 현재는 대부분 TCP 사용 (인터넷이 TCP 기반)
    - 클라이언트도 서버도 SYN (접속 요청)를 보냄
    - 마지막 과정인 클라이언트에서 ACK를 서버로 보낼때 이때 데이터도 함께 전송 (가능)
  - [UDP]
    - 사용자 데이터그램 프로토콜 (User Datagram Protocol)
    - 하얀 도화지에 비유됨
    - 연결지향 X
    - 순서 보장 X
    - IP와 거의 같으나 포트 + 체크섬 (검증용) 정보가 추가
      - 들어오는 여러개의 패킷 중에 어느것이 게임용이고 어느것이 또 다른 목적의 패킷인지를 구분하기 위함.
    - 데이터 전달 및 순서가 보장되지 않지만 단순하고 속도 빠름
- [PORT]
  - 항구 뜻
  - 배경: 한번에 둘 이상 연결하려면?
    - 같은 아이피 안에서 게임하면서 화상통화 하면서 웹 브라우저 요청의 예
  - 몇동 몇호의 개념, ip는 아파트
  - 0 ~ 65535 까지 할당 가능
  - 0 ~ 1023은 사용 지양
  - FTP: 21, 20
  - HTTP: 80
  - TELNET: 23
  - HTTPS: 443
- [DNS]
  - 배경: ip는 변경될 가능이 있으며 기억의 어려움
  - 도메인 네임 시스템 (전화번호부같은 서버)
  - DNS 서버에 도메인 등록 (google.com : 200.0.0.1)
  - DNS 서버에 google.com ip 요청 --> ip 입수 후 해당 ip로 접속

#### 인터넷 프로토콜 스택의 4계층, 메시지 송신 순서 설명

- 애플리케이션 계층 - HTTP, FTP (소켓 라이브러리, 채팅, 네트워크 게임)
- 전송 계층 - TCP, UDP
- 인터넷 계층 - IP (Internet Protocol)
- 네트워크 인터페이스 계층 (LAN 드라이버, 장비)
- 실제 메세지 전송 과정
  - 프로그램이 즉, 앱이 Hello World 메세지 생성
  - 소켓 라이브러리를 통해 메세지 전달
  - TCP 정보 생성하여 메세지 데이터를 Wrapping (메세지 데이터를 포함 시킴)
  - IP 패킷 정보 생성하여 TCP 데이터를 Wrapping (TCP 데이터를 포함 시킴)
  - Wrapping된 IP 패킷 데이터가 랜카드로 이동
  - 랜 카드에서 인터넷 망을 통해 서버로 이동 (랜카드를 통해서 나갈 때 Ethernet Frame*을 포함하여 나감)

#### API 설명

- Application Programming Interface 의 약자
- 프로그램들이 서로 통신하거나 상호작용 할 수 있도록 도와주는 매개체이자 약속
- API 에 대한 이해를 쉽게 하기 위한 비유
  - 회사에서 팀장과 팀원들간에 다음과 같은 소통이 일어난다 가정
    - 팀장이 팀원들에게 오늘 할 업무 목록을 물어봅니다.
    - 팀장이 각 팀원들에게 해야할 업무를 지정해 줍니다.
- 만약 팀장과 팀원이 프로그램으로 바뀐다면 어떻게 될까?
  - 바로 다음과 같은 API 를 정의하여 서로 소통하게 됨
    - 업무 목록 조회 API
    - 업무 지시 API
- 프로그램에서 이런 API 를 정의했을 때 좋은점
  - client 프로그램은 소통할 프로그램이 어떤 프로그램인지, 구현이 어떻게 되어있는지 신경쓰지 않고 약속된 API 만 사용하면 소통이 가능
  - 위의 예를 들어 팀장이 소통할 팀원들 중 한사람은 말하는걸 좋아하고 한사람은 에어팟을 꽂아 소리를 못듣는 사람이 있을 경우 팀장은 자신이 소통할 팀원이 누구냐에 따라 신경써서 다르게 접근해야 함
  - API 를 사용할 경우 이미 약속된 내용이기 때문에 상대방이 누구든 상관없이 API 만 호출하면 원하는 결과를 얻을 수 있음
- 공통된 로직을 효율적으로 관리 가능
  - 하나의 프로그램과 소통하는 여러 Client 프로그램이 있을 경우 각각의 Client 에서 똑같은 로직을 들고 있는것보단 하나의 프로그램에서 공통된 로직을 제공해주는게 효율적이고 유지보수적으로도 편리
- 유지 보수 및 확장이 용이
  - HTTP 와 같은 범용 프로토콜을 사용하는 API 의 경우 웹, 안드로이드, IOS 환경에서 동일한 API 를 사용할 수 있어 서로 다른 환경에서 동일한 기능 구현이 간편해짐
  - 또한 API 에 버그가 있거나 개선사항을 진행하게 될 경우 API 를 제공하는 프로그램만 수정하면 되기 때문에 유지 보수적으로도 효율적
- 인터넷을 통해 병합된 컴퓨터들 간의 통신시 사용하는 API 를 웹 API 라고 불리기도 함
- 웹 API 의 경우 API 를 정의했던 시기와 이유에 따라 다음과 같은 종류로 나뉘어짐
  - SOAP API 
    - 단순 객체 접근 프로토콜을 사용
    - 클라이언트와 서버는 XML을 사용하여 메시지를 교환
    - 과거에 더 많이 사용되었으며 유연성이 떨어지는 API
  - RPC API
    - 원격 프로시저 호출
    - 클라이언트가 서버에서 함수나 프로시저를 완료하면 서버가 출력을 클라이언트로 다시 전송
  - Websocket API
    - JSON 객체를 사용하여 데이터를 전달하는 또 다른 최신 웹 API 개발
    - WebSocket API는 클라이언트 앱과 서버 간의 양방향 통신을 지원
    - 서버가 연결된 클라이언트에 콜백 메시지를 전송할 수 있어 REST API보다 효율적
  - REST API
    - 오늘날 웹에서 볼 수 있는 가장 많이 사용되고 유연한 API
    - 클라이언트가 서버에 요청을 데이터로 전송
    - 서버가 이 클라이언트 입력을 사용하여 내부 함수를 시작하고 출력 데이터를 다시 클라이언트에 반환

#### ORM

- 데이터베이스와 어플리케이션의 연결을 ‘객체지향’적으로 도와주는 ORM(Object Relational Mapping)
- 객체로 연결을 해준다는 의미로, 어플리케이션과 데이터베이스 연결 시 SQL언어가 아닌 어플리케이션 개발언어로 데이터베이스를 접근할 수 있게 해주는 툴
- SQL문법 대신 어플리케이션의 개발언어를 그대로 사용할 수 있게 함으로써, 개발 언어의 일관성과 가독성을 높여준다는 장점이 있음
- 언어 예
  - 파이썬 Flask SQLAlchemy
- 예를 들어 파이썬 Flask SQLAlchemy의 메소드를 활용해 SQL데이터를 생성하고 조회할 수 있기 때문에 가독성이 높아지고 개발언어를 일관되게 활용할 수 있어 편리
- ORM은 백엔드 개발에 있어 개발언어의 일관성과 가독성을 높여주는 강력한 장점
- 다만, ORM만으로는 SQL의 모든 부분을 다루기가 어렵기 때문에 백엔드 개발 시 SQL 쿼리에 대한 지식과 경험이 바탕이 되어야 더 효과적인 백엔드 개발이 가능

#### URI, Web Browser 요청 흐름

- URI
  - Uniform Resource Identifier
  - 리소스를 식별하는 통합된 방법 (통일된 방식)
  - 로케이터, 이름 또는 둘다 추가로 분류될 수 있음?
  - URI (Resource Identifier) > URL (Resource Locator) + URN (Resource Name)
  - URL: http://xxx.xxx:8080/xxx (리소스가 있는 위치를 지정)
    - scheme:// <-- 프로토콜 (어떤 방식으로 자원에 접근할 것인가하는 약속 규칙, http, ftp)
    - scheme://[userinfo$]xxx
    - scheme://host(:port)
    - /path, ?query (?what=hello&when=mon), #fragment
    - query ?는 키, 값 형태
    - #fragement: html 내부 북마크 등에 사용
  - URN: urn:xxx:xxx:xx:xxx (리소스에 이름 부여, 책 isbn)
  - 위치는 변할 수 있지만 이름은 변하지 않음
- 웹 브라우저 요청 흐름
  - HTTP 메세지 생성
  - 소켓 라이브러리 통해 전달
    - TCP/IP 연결(IP, PORT)
    - 데이터 전달
  - TCP/IP 패킷 생성, HTTP 메세지 포함
    - 출발지, 목적지 IP & PORT
    - HTTP 메세지 예: GET /search?q=hello&hl=ko HTTP/1.1 Host: www.google.com
    - HTTP 응답 메세지 예: HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 ...
  - TCP/IP 패킷 내 HTTP 메세지 즉 html 부분을 렌더링 시작

#### HTTP

- HyperText Transfer Protocol (HTML 전송, 지금은 모든것 전송)
  - 문서 간의 링크를 통해 연결
- HTTP/1.1 (1997): 현재 가장 많이 사용, 중요 버전
  - RFC2068 -> RFC2616 (1999) -> RFC7230~7235 (2014)
  - HTTP/2, /3은 성능 개선, /3은 UDP 사용, 성능 개선
- 기반 프로토콜
  - TCP: HTTP/1.1, 2
  - UDP: HTTP/3
- Chrome inspector -> Network 에서 protocol 컬럼에서 HTTP 버전 볼수 있음
  - h2, http/1.1 etc
- 클라이언트 서버 구조
- 무상태 프로토콜, 비연결성
- HTTP 메시지
- 단순함, 확장 가능

#### 클라이언트 - 서버 구조

- Request - Response 구조


#### 무상태 프로토콜 (Stateless)

- 서버가 클라이언트 상태를 보존하지 않음
- 갑자기 고객이 증가해도 대처 가능
- 전송 데이터가 Stateful에 비해 많음
- 무상태는 응답 서버를 쉽게 변경 가능 --> 무한 서버 증설 가능
- 상태 유지: Statefule 의 경우
  - 항상 같은 서버 유지 필요
  - Step 중 1번 스텝 처리 중 1번 서버가 죽으면 처음부터 다시 진행해야 하는 문제점
  - 1번 서버가 죽어도 모든 정보를 보내고 있기 때문에 다음 서버로 이동해서 진행 가능
- 예제
  - 무상태: 단순 서비스 소개 화면
  - 상태 유지: 로그인 (일반적으로 브라우저 쿠키와 서버 세션들을 사용해서 유지)

#### 비연결성

- 최소한의 자원 유지 (서버측)
- HTTP 는 기본이 연결을 유지하지 않는 모델
- 서버 자원 효율적 사용 가능
- 단점
  - TCP/IP 연결을 새로 맺어야 함 (3Way Handshake)
  - 웹 브라우저로 사이트 요청 시 -> HTML + CSS + JS + 기타 이미지 등 다운로드
  - HTTP 지속 연결 (Persistent Connections)으로 문제 해결
    - 몇 십초동안 유지 등의 메커니즘 존재

#### HTTP 메세지

- 메세지 구조 (요청과 응답 메시지 구조가 다름), RFC7230 스펙
  - start-line
    - request-line / status-line
    - 종류: GET, POST, PUT, DELETE
    - 절대경로 /로 시작하는 경로, ? 쿼리문 혼합
    - 응답 메시지: HTTP-version SP status-code SP reason-phrase CRLF
  - header
    - OWS 띄어쓰기 허용 (참고)
    - field name은 대소문자 구분 없음
    - HTTP 전송에 대한 필요한 모든 부가 정보 포함
      - 메시지 바디 내용, 바디 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보, 서버 앱 정보 등
    - Host: www.google.com
      - field-name ":" OWS field-value OWS
  - empty line (CRLF) 엔터, 공백 라인
  - message body
    - 실제 전송할 데이터 포함
    - 바이트로 표현 가능한 모든 데이터 전송 가능

#### HTTP Method

- HTTP API 구축 과정
  - URI 설계 (/read-xxxx, /modify-xxx?)
    - 맨 처음에 이런식으로 설계.
    - 리소스 의미: 회원조회라고 하면 회원이라는 개념 자체가 리소스
      - 추가 설명: 회원을 조회해라라는 것이 리소스가 아니고 회원 자체가 리소스 (member)
  - URI 재 설계
    - /members, /members/{id} (조회), /members/{id} (등록)...
    - 조회, 등록, 수정, 삭제, 전체 조회를 어떻게 구분할 건인가?
  - 리소스와 행위를 구별, URI는 리소스만 식별.
    - 행위: HTTP Method (GET, POST, PUT, DELETE, PATCH)

#### RDB vs NoSQL

- RDB
  - 테이블 형식의 데이터 저장 모델
  - 데이터 중복 없음
  - 데이터 변경이 잦은 경우
- NoSQL
  - Json Document, Key Value 기반 데이터 저장 모델
  - 새로운 필드 추가 용이
  - 데이터 중복 존재
  - 업데이트가 잘 없고 데이터양이 많고 단순 조회가 많을 경우 사용

#### HTTP Method - GET, POST

- GET: 리소스 조회
  - Message Body 사용하여 데이터 전달 가능하나 중간에 지원 불가능한 서버도 있으므로 권장되지 않음, 보통 쿼리로 전달
  - 메세지 바디를 활용해야 하는 경우는 POST 사용하여 조회 (조회 이지만 포스트를 사용)
- POST: 요청 데이터 처리, 주로 등록에 사용
  - Message Body 통해 서버로 요청 데이터 전달 - 서버는 요청 데이터 처리
  - 신규 리소스 생성/등록, 변경된 프로세스 처리에 사용
    - 프로세스 변경? 결제 완료 --> 배달시작 --> 배달 완료와 같이 값 변경을 넘어 프로세스 상태 변경되는 경우
    - 서버에서 큰 변화가 일어나는 것은 리소스가 생성되지 않더라도 포스트 사용 필수
  - 흐름
    - 바디에 요청 데이터 넣어서 서버로 요청
    - 서버는 예를 들어 /members/100 이라는 신규 리소스 생성
    - /members/100 을 클라이언트로 응답 (201 Created, Location: /members/100)
  - 예
    - html 양식에 입력된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공
    - 게시판 글쓰기, 댓글 달기
    - 서버가 아직 식별하지 않은 새 리소스 생성 (신규 주문 생성)
    - 기존 자원에 데이터 추가
  - 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해줘야 함 - 정해진 것이 없음
  - 예외사항: 컨트롤 URI <-- 예외적인 리소스 (start-xxx)
- PUT: 리소스 대체, 해당 리소스 없으면 생성 (파일을 폴더에 넣은 행위와 유사)
  - 클라이언트가 리소스 위치를 인지하고 직접 URI 지정 (포스트와 차이점)
    - POST는 /members (POST) <--- 리소스가 100번에 지정될 지 200번이 될지 모름
    - PUT은 /members/100 (PUT) <-- 사용자가 정확하게 리소스를 알고 있음
  - 완전히 대체 (덮어쓰기)
    - username, age가 있을 때 age 필드만 넣고 PUT하는 경우 username은 삭제됨 (리소스가 대체되므로)
    - 수정하는게 아니라 갈아치우는 느낌
  - 스토어
- PATCH: 리소스 부분 변경
  - 부분만 수정하고 싶을 때 사용 (PUT에서의 완전 대체 현상 극복)
  - 패치 지원안되는 경우도 있음 <-- POST 사용하면 됨
- DELETE: 삭제
- 추가 메소드 (참고)
  - HEAD: GET과 동일, 메시지 제외하고 상태 줄과 헤더만 반환
  - OPTIONS
  - CONNECT
  - TRACE

#### HTTP 메소드의 속성

- 안전 (Safe Methods)
  - 호출해도 리소스 변경하지 않음
  - 예. GET, HEAD (Body만 뺀것)
- 멱등 (Idempotent Methods)
  - f(f(x)) = f(x)
  - 1~100번 호출하든 결과 동일
  - 예. GET, PUT (똑같은 요청을 여러번), DELETE
  - POST는 멱등이 아님 (두번 호출 시 같은 결제가 중복해서 발생할 가능성, 배송 두번 누르는 것)
  - 동일 인풋을 줬을 때 아웃풋이 같은가에 초점
  - 왜 필요한가?
    - 자동 복구 메커니즘
    - 서버 타임아웃 등으로 정상 응답 못주었을 때 클라이언트가 같은 요청을 해도 되는가?
  - GET, PUT, GET으로 인한 외부 요인으로 인한 리소스 변경은 고려하지 않음
    - 여러 사용자에 의한 외부 요인 등
    - 동일한 사용자가 똑같은 요청을 여러번 한것에 대해서만 고려!!!!!
- 캐시가능 (Cacheable Methods)
  - 응답 결과 리소스를 캐시해서 사용해도 되는가?
  - GET, HEAD, POST, PATCH 는 캐시 가능 (실제로 GET, HEAD 정도만 캐시로 사용)
  - POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데 구현이 쉽지 않으므로 잘 사용되지 않음

#### HTTP 메소드 활용

- 클라이언트에서 서버로 데이터 전송
  - 쿼리 파라미터 (GET) 통한 데이터 전송
    - 예: 정렬 필터(검색어)
  - 메시지 바디
    - POST, PUT, PATCH
    - 회원가입, 주문, 리소스 등록, 변경
  - 4가지 상황
    - 1) 정적 데이터 조회
    - 2) 동적 데이터 조회 (주로 검색, 게시판 목록에서 정렬 필터(검색어), 쿼리 파라미터 사용하여 데이터 전달)
    - 3) HTML Form 데이터 전송 (<Form> 태그)
      - Post 전송 (회원 가입 / 주문 / 데이터 변경) / GET도 가능
        - HTML Form 전송은 GET, POST만 지원!!
      - 웹브라우저가 Form 태그 데이터를 조합하여 HTTP 메시지를 생성
      - application/x-www-form-urlencoded (username=xxx&age=20)
        - 전송 데이터를 url encoding 처리해서 전달
        - 예: abc김 --> abc%EA%B9%80
      - 폼 태그 method에 따라 값을 넣는 경로가 달라짐
        - GET이면 쿼리, 포스트면 바디에 들어감
      - Multipart/form-data
        - form 태그 내 enctype="multipart/form-data"
        - boundary
        - 바이너리 데이터 전송 시 사용?
    - 4) HTTP API 데이터 전송
      - 보통 클라이언트에 HTTP 요청 데이터를 만들어주는 라이브러리가 존재
      - 서버 to 서버
      - 앱 클라이언트
      - 웹 클라이언트 (AJAX, React, VueJs)
      - POST, PUT, PATCH (메시지 바디 통한 데이터 전송)
      - GET (조회, 쿼리 파라미터로 데이터 전달)
      - Content-Type: application/json 주로 사용 (거의 표준)
        - TEXT, XML, JSON 등

#### HTTP api 설계 예시 정리

- HTTP API - 컬렉션
  - 포스트 기반 (대부분 사용)
    - /members <-- 컬렉션이라 부름
    - 서버가 관리하는 리소스 디렉토리 <-- 컬렉션
    - 서버가 리소스의 URI를 생성하고 관리
    - Post 신규 자원 등록 특징
      - 클라이언트는 등록될 리소스의 URI를 모름
  - 풋 기반
    - 스토어
    - 클라이언트가 리소스 URI 결정
    - 클라이언트가 관리하는 리소스 저장소 (/files/xxx.jpg)
- HTML FORM 사용 (순수 HTML, HTML Form 사용한다 가정)
  - GET, POST만 지원
  - POST의 /new, /edit, /delete 가 컨트롤 URI 또는 컨트롤러
  - 컨트롤 URI --> HTTP 메소드로 해결하기 힘든 경우 사용
  - Form을 보는것은 get, 실제 수정, 등록할때는 POST
    - /members/new, /members/{id}/edit, /members/{id}/delete (POST, Delete 사용이 불가하므로 어쩔수 없이 컨트롤 URI 사용 필수)
- URI 설계 개념 (참고)
  - 문서 (document) --> /members/100, files/star.jpg
  - 컬렉션 (collection) --> /members
  - 스토어 (store) --> /files
  - 컨트롤러 / 컨트롤 URI --> /members/{id}/delete
    - 문서, 컬렉션, 스토어로 해결하기 힘든 추가 프로세스 실행
    - 동사를 직접 사용 (ex. /members/{id}/delete)

#### HTTP 상태코드

- 1xx (Informational): 요청이 수신되어 처리중
- 2xx (Successful): 요청 정상 처리
  - 200 OK
  - 201 Created (Post, 요청 성공해서 새로운 리소스가 생성됨)
    - 생성된 리소소는 응답의 Location 헤더 필드로 식별
  - 202 Accepted
    - 요청이 접수, 처리는 완료되지 않은 상태
    - 배치 처리
  - 204 No Content
    - 서버가 요청을 성공적으로 수행하였으나 응답 페이로드 본문에 보낼 데이터가 없는 경우
    - 예. 웹 문서 편집기에서 저장 버튼 (저장 버튼 결과로 아무 내용이 없어도 됨)
- 3xx (Redirection): 요청을 완료하려면 추가 행동이 필요 (User Agent의 추가 조치 필요, User Agent: 웹 브라우저)
  - 리다이렉션: 3xx 응답 결과에 Location 헤더가 있으면 그 위치로 이동
  - 자동 리다이렉션 흐름
    - GET /event
    - Response (301, Moved Permanently, Location: /new-event)
    - GET /new-event (Web browser가 다시 처음부터 요청)
    - Response (200 OK)
  - 리다이렉션 종류
    - 영구: 특정 리소스의 URI가 영구적으로 이동 / 검색 엔진 등에서도 변경 인지
      - 301: 리다이렉트 시 요청 메소드가 GET으로 변하고 본문이 제거 될 수 있음
        - 흐름 예: POST (본문도 같이) --> /new-event --> GET /new-event --> 200 OK (본문은 제거)
      - 308: 301과 기능 동일 / 처음 메소드와 본문 유지 (실무에서는 빈도 낮음)
        - 흐름 예: POST (본문도 같이) --> /new-event --> POST /new-event, 본문 유지 --> 200 OK
    - 일시: 주문 완료 후 주문 내역 화면으로 이동하는 예 / PRG (Post/Redirect/Get)
      - 302 Found: 리다이렉트 시 요청 메소드가 GET으로 변하고 본문이 제거 될 수 있음 (실무에서 자주 사용)
      - 307 Temporary Redirect: 리다이렉트 시 요청 메소드와 본문 유지 --> 메소드가 변하면 안됨
      - 303 See Other: 302와 기능 동일, 리다이렉트 시 요청 메소드가 GET으로 변경
      - 일시적인 리다이렉션 예시
        - 문제 상황
          - POST 주문 후 웹 브라우저 새로고침 시
          - 새로고침은 다시 요청
          - 중복 주문이 될 수 있음
          - 흐름: POST --> 200 OK --> POST --> 200 OK
        - PRG 사용
          - POST 주문 후 주문 결과 화면을 GET 메소드로 리다이렉트
          - 새로고침해도 결과 화면을 GET으로 조회
          - 결과화면만 GET으로 다시 요청
          - 흐름: POST --> 302 Found --> Get --> 200 OK
    - 특수: 결과 대신 캐시를 사용 (다운로드 할 필요없이 캐시사용하면 될 때 응답)
      - 300 (Multiple Choices)
      - 304 (Not Modified)
        - 캐시 목적
        - 클라이언트에게 리소스가 수정되지 않았음을 알리고 클라이언트는 로컬 PC에 저장된 캐시를 재사용 (캐시로 리다이렉트)
        - 로컬 캐시를 사용해야 하므로 응답은 메시지 바디를 포함하면 안됨
        - 조건부 GET, HEAD 요청 시 사용
- 4xx (Client Error): 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
  - 오류 원인이 클라이언트에 존재
  - 클라이언트가 이미 잘못된 요청 / 데이터를 보내고 있기 때문에 똑같은 재시도해도 계속 실패함 (500대는 서버가 고쳐지면 실패하지 않음)
  - 400 (Bad Request): 파라미터 또는 API 스펙 맞지 않을 때
  - 401 (Unauthorized): 클라이언트가 해당 리소스에 대한 인증이 필요
    - 오류 발생 시 응답에 WWW-Authenticate 헤더와 함께 인증방법을 설명
    - 인증, Authentication: 본인이 누구인지 (로그인)
    - 인가 (Authorization)
    - Unauthorized
  - 403 Forbidden
    - 서버가 요청 이해하였으나 승인 거부
    - 인증 자격 증명은 통과 (로그인은 됨)하나 접근 권한이 충분하지 않은 경우
  - 404 Not Found
    - 요청 리소스 찾을 수 없음
    - 클라이언트가 권한이 부족한 리소스에 접근할 때 / 해당 리소스를 숨기고 싶을 때
- 5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함
  - 서버 복구 시 에러나지 않음 (서버 내부 문제)
  - 503 (Service Unavailable) 서비스 이용 불가
    - 일시적인 과부하, 잠시 요청 보류 (서버)
    - Retry-After 헤더필드로 얼마뒤에 복구되는지도 보낼수 있음
- 예외적인 코드 발생 시 상위 상태코드로 해석해서 처리
  - 299 --> 200
  - 451 --> 400