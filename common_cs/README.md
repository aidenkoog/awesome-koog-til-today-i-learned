#### 블로킹, 논블로킹, 동기, 비동기에 대한 설명

- 블로킹, 논블로킹: A 함수가 B 함수를 호출했을 때 **제어권을 어떻게 처리하느냐에** 따라 달라진다.
  - **블로킹**: A 함수가 B 함수를 호출하면, 제어권을 A가 호출한 B함수에 넘겨준다.
  - **논블로킹**: A 함수가 B 함수를 호출해도 제어권은 그대로 자신이 가지고 있음.
- 동기, 비동기: 호출되는 **함수의 작업 완료 여부를 신경쓰는지**의 여부 차이
  - **동기**: 함수 B의 리턴값을 계속 확인하면서 신경쓰는 것
  - **비동기**: 함수 A가 B를 호출할 때 콜백 함수를 함께 전달, 함수 B의 작업이 완료되면 콜백 함수를 실행. 함수 A는 B를 호출한 이후로 함수 B의 작업 완료 여부에는 신경쓰지 않음.
- **Sync Blocking**
  - 함수는 다른 함수의 리턴값을 고려해서 동작 (동기)
  - 함수는 다른 함수에게 제어권을 넘겨주고 대기 (블로킹)
- **Sync NonBlocking**
- **Async-NonBlocking**
- **Async-blodking**

#### 동기와 비동기의 차이

- 동기(Synchronous) 방식
  - 요청을 보내고 실행이 끝나면 다음 동작을 처리하는 방식
  - 순서에 맞추어 진행되기 때문에 제어 쉬움
  - 여러가지 요청을 동시에 처리할 수 없어 효율 낮음
  - Ex. 콜센터 종업원이 일을 처리하는 방식. 콜센터의 직원은 한 손님의 전화 응대가 끝난 후에 다음 손님의 응대를 진행 가능
- 비동기(Asynchronous) 방식
  - 요청을 보내고 해당 동작의 처리 여부와 상관없이 다음 요청이 동작하는 방식
  - 작업이 완료되는 시간을 기다릴 필요가 없기 때문에 자원을 효율적으로 사용 가능
  - 작업이 완료된 결과를 제어하기 어려움
  - Ex. 이메일. 우리는 한 사람에게 이메일을 보냈을 때 답변을 받지 않고도 이메일을 다시 보내는 것이 가능

#### 컴퓨터 구조 설명

- 컴퓨터
  - [하드웨어]
    - 중앙처리장치
      - 연산 장치
      - 제어 장치
    - 기억장치
      - 주기억 장치
      - 보조기억장치
    - 입출력장치
  - [소프트웨어]
    - 시스템 (하드웨어 제어 / 관리)
      - 펌웨어, 운영체제, 컴파일러, 장치 드라이버 (저수준 언어)
    - 응용 (일반 사용자 작업 수행 도움)
      - 앱 (고수준 언어)

#### 하드웨어 구성요소 설명

- CPU
  - ALU (Arithmetic Login Unit)
  - Register
    - ALU <--> Register 서로 데이터 주고 받음
  - Control Unit
  - Bus Interface
- Main Memory
- Etc
  - Keyboard / Monitor / Network Card / Hard Disk

#### 기억장치 설명

- 속도 순서
  - 보조기억장치 < 메인메모리 (DRAM) < 캐시메모리 (SRAM) < 레지스터

#### 메인 보드 설명

- 다양한 물리적인 장치를 장착할 수 있는 인쇄회로기판 (PCB)
- 부품에 대한 인터페이스 제공
- 마더보드 = 메인보드

#### GPU 설명

- Graphics Processing Unit
- 그래픽 연산을 빠르게 처리하는 답을 도출하는 연산 장치
- 인공지능, 고화질 게임, 무인 자동차 등에 주로 사용
- 대규모 행렬 / 벡터 연산 처리에 탁월

#### 보조 기억 장치 설명

- 메인 메모리보다 속도 느림
- 전원 차단되어도 내용 유지 / 저장 용량 큼
- 종류
  - 하드 디스크
  - SSD (전력 소비 적음, 사용 수명이 HDD 에 비해 상대적으로 낮음)

#### 메모리 설명

- 컴퓨터에서 작업을 수행하기 위해 처리 대상이나 결과 등을 저장하기 위한 공간
- 프로그램을 실행하기 위한 정보들은 메모리에 저장되어 처리됨.

#### 메인 메모리 설명

- [주기억장치]
- RAM (Random Access Memory)
- 전원이 사라이면 저장 내용 사라짐 (휘발성)
- 프로그램 실행 시 프로그램은 메인 메모리에 적재 (프로세스 형태)
- CPU 는 메인 메모리에 적재된 프로그램 명령 코드를 읽어 들여 실행 / 처리

#### CPU 설명

- Central Processing Unit
- 인간의 뇌와 같은 역할 수행
- 연산 + 제어 담당
- ALU 연산 장치 사용
- 메인 메모리에서 명령어를 읽어, 계산한 뒤에 메인 메모리에 저장
- 모듈 (서로 내부적인 버스로 연결)
  - [산술/논리] 장치 (ALU)
    - 가장 빠른 연산 장치
    - 연산 처리
  - [제어장치] (Control Unit)
    - 메인 메모리에 적재된 처리해야 될 데이터 해석 / 제어 신호 생성
    - ALU에게 연산 수행 명령
    - 메인 메모리에 대한 읽기 / 쓰기 등의 제어 명령 내림
  - [레지스터]
    - 임시적으로 데이터를 담을 수 있는 장소
    - CPU의 현재 상태를 저장
    - 실제 연산은 CPU 내부에서 처리 되므로 필요한 데이터를 저장

#### 프로그램 수행 절차 설명

- 1. 프로그램 실행
- 2. 보조 기억 장치 내 프로그램이 메인 메모리로 적재
- 3. 프로그램의 코드 영역의 명령어를 읽어 명령 수행
- 4. 명령어 인출 / 해석 / 실행 사이클 반복
  - fetch: 메인 메모리에서 수행할 명령어를 레지스터로 가져옴
  - decode: 명령어 정보 해석
  - execute: 제어 장치가 명령어 수행을 위한 적절한 제어 신호를 보내 실행

#### 캐시 메모리 설명

- 빠른 CPU와 상대적으로 느린 메인 메모리 사이 위치
- 두 장치 속도 차이에서 오는 병목 현상을 보상/완화 하기 위해 사용
- Main Memory <--> Level3 <--> L2 <--> L1 <--> CPU
- 메인 메모리에서 CPU로 적재할 데이터를 레지스터에 적재하기 전 캐시에 보관
- 데이터 접근 시 캐시 메모리에서 먼저 데이터 검색
- 캐시 히트
  - 원하는 데이터를 찾은 것
  - 데이터를 찾은 경우 메인 메모리에 접근하지 않아도 되므로 시간 효율적
- 기본 동작 과정
  - 데이터를 메인 메모리에서 캐시로 복사
  - 캐시에서 데이터를 꺼낸 뒤에 CPU가 처리
  - CPU는 데이터 접근이 필요한 경우 캐시 메모리를 먼저 검사 / 가져옴
  - 캐시에 데이터 없는 경우 메인 메모리에서 캐시 메모리로 해당 데이터 복사

#### CPU의 메모리 I/O 도중 생기는 병목 현상 해결 방법

- 메모리의 계층화를 통한 현상 해결
- 자주 접근하는 데이터의 경우에는 캐시 메모리에 저장하여 접근 속도를 향상 시킴으로서 부하를 감소

#### 가상 메모리와 페이지 폴트 설명

- **가상메모리**
  - RAM 의 부족한 용량 보완을 위해 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식
  - OS는 프로세스들의 내용 (페이지) 중에서 덜 중요한 것들을 HDD로 옮겨 놓고, 관련 정보를 페이지 테이블에 기록
- **페이지폴트**
  - CPU는 프로세스를 실행하면서 페이지 테이블을 통해 페이지를 조회하는데 실제 메모리에 원하는 페이지가 없는 상황이 발생하는 것 (Valid Bit를 통해 확인)
  - 실제 메모리에 필요한 데이터(페이지)가 없으면 가상메모리를 통해 해당 데이터를 가져오게 되는데 가상메모리는 HDD에 저장되어 있기 때문에 페이지 폴트 발생하면 I/O에 의한 속도 저하가 발생함

#### 페이지 교체 알고리즘과 LRU (Least Recently Used) 설명

- **LRU**
  - Least Recently Used, 페이지를 교체하기 위한 알고리즘 중 하나
  - 실제 메모리의 페이지들 중에서 가장 오랫동안 사용되지 않은 페이지를 선택하는 방식
- **페이지-교체**에 대한 설명
  - 교체 이유는 가상메모리를 통해 조회한 페이지는 다시 사용될 가능성이 높기 때문임
  - 교체를 위해서는 실제 메모리에 존재하는 페이지를 가상 메모리로 저장한 후에, 가상 메모리에서 조회한 페이지를 실제 메모리로 로드해야 함
  - 이 과정에서 어떤 실제 메모리의 페이지를 가상 메모리로 희생시킬 것이냐에 대한 문제가 발생하는데 이때 사용하는 알고리즘 중 하나가 LRU 알고리즘
- 그 외 알고리즘 정보
  - 먼저 적재된 페이지를 희생시키는 FIFO 알고리즘
  - LRU 알고리즘 응용하여 페이지에 Second-Change를 주는 LRU Approximation 등이 존재

#### 웹 캐시 설명

- Web Cache
- 웹 브라우저의 경우 자주 방문하는 웹 사이트에 대해 자주 쓰이는 데이터를 저장
- 웹 데이터를 캐시 처리 => 웹 캐시
- 자주 접속하는 사이트의 이미지, HTML 등에 대해 특정 저장 공간에 저장

#### 노트북 (Laptop) 특징 설명

- 휴대용
- 모니터, 키보드, 카메라, 메인보드, CPU, 그래픽 카드 등이 한꺼번에 탑재
- 편리하여 수요 높음

#### 프로세스와 스레드 차이점

- 참고. 프로그램: 어떤 작업을 위해 실행할 수 있는 파일
- 프로세스
  - 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
  - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스 (독립적인 개체)
  - 운영체제로부터 시스템 자원을 할당받는 작업 단위
    - CPU 시간 / 운영에 필요한 주소 공간 / 코드-데이터-스택-힙의 구조로 되어 있는 독립된 메모리 영역
  - 실행된 프로그램
  - 프로세스는 운영체제로부터 각각 독립된 메모리 영역을 할당받음
  - 최소 1개의 스레드 (메인 스레드)를 가지고 있음
  - 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근 불가능
  - 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신 필요
    - IPC : Inter-Process Communication
    - Ex. 파이프, 파일, 소켓 등을 이용한 통신 방법 이용
- 스레드
  - 프로세스 내에서 실행되는 여러 흐름의 단위
  - 프로세스의 특정한 수행 경로
  - 프로세스가 할당받은 자원을 이용하여 동작하는 실행 단위
  - 스레드는 각각 스택만 따로 할당받고 나머지 메모리 영역인 코드, 데이터, 힙 영역은 공유
    - 스택 분리 이유: 스택에는 함수 호출 정보가 저장되는데 스택을 공유하면 LIFO 구조에 의해 실행 순서가 복잡해지기 때문에 실행 흐름을 원활하게 만들기 위한 목적
  - 프로세스 내의 주소 공간이나 자원을 같은 프로세스 내 스레드끼리 공유하면서 실행
  - 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간 공유
  - 별도의 레지스터와 스택 가지고 있음
  - 프로세스의 자원을 서로 공유하기 때문에 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드도 그 변경 결과를 즉시 볼 수 있음
  - 자바 스레드 (Java Thread)
    - JVM이 운영체제의 역할, 나머지는 일반 스레드와 동일
    - 자바에는 프로세스는 존재 X, 스레드만 존재
    - JVM에 의해 스케쥴되는 실행 단위 코드 블록
    - 스레드 스케쥴링은 전적으로 JVM에 의해 이루어짐
    - JVM 이 관리하는 항목
      - 스레드 개수
      - 스레드로 실행되는 프로그램 코드의 메모리 위치
      - 스레드 상태
      - 스레드 우선순위
    - 개발자는 스레드 코드 작성 후 그 코드가 실행을 시작하도록 JVM에 요청하는 일을 하는 것

#### 멀티 프로세스와 멀티 스레드의 차이

- 멀티 프로세스
  - 멀티 프로세싱
    - 하나의 응용 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(Task)을 처리하도록 하는 것
  - 여러 개 프로세스 중 하나에 문제가 생겨도 전체 흐름에 영향 없음
  - 단점
    - Context Switching 에서의 오버헤드
      - Context Switching: CPU에서 여러 프로세스를 돌아가면서 작업 처리하는 과정
      - 캐쉬 메모리 초기화 / 인터럽트 등의 무거운 작업 진행 및 많은 시간 소요
      - 프로세스 특성 상 서로 공유하는 메모리가 없고 각각 독립적인 메모리를 할당받았기 때문에 컨텍스트 스위칭이 발생하면 캐쉬에 있는 모든 데이터를 리셋하고 다시 데이터를 불러와야 하는 문제 있음
      - CPU 레지스터 교체 / RAM, CPU 사이 캐쉬 메모리 데이터 초기화
- 멀티 스레드
  - 하나의 응용 프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것
  - 웹 서버는 대표적인 멀티 스레드 프로그램
  - 장점
    - 시스템 자원 소모 감소 (효율성 증대)
      - 프로세스 생성 후 자원 할당을 위한 시스템 콜이나 컨텍스트 스위칭 오버헤드가 줄어들어 자원을 효율적으로 관리 가능
    - 시스템 처리량 증가 (처리 비용 감소)
      - 데이터 공유가 간단, 자원 소모 감소
      - 작업량이 작아 컨텍스트 스위칭이 빠름
    - 간단한 통신 방법으로 인한 응답 시간 단축
      - 스택을 제외한 나머지 모든 메모리 영역을 공유하기 때문에
  - 단점
    - 설계 주의
    - 어려운 디버깅
    - 단일 프로세스 시스템의 경우 효과를 기대하기 어려움
    - 다른 프로세스에서 스레드 제어 불가능
    - 자원 공유의 문제 발생 (동기화)
      - 전역 변수 (데이터 세그먼트) 이용한 자원 공유가 이루어지므로 함께 사용 시 동기화 문제 발생 가능성 (여러 쓰레드가 하나의 자원에 동시에 접근하는 경우)
    - 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향 받음

#### 데드락(DeadLock) 설명

- 데드락(DeadLock) 또는 교착상태란 한정된 자원을 여러 프로세스가 사용하고자 할 때 발생하는 상황
- 프로레스가 자원을 얻기 위해 영구적으로 기다리는 상태
- Ex. 데드락 발생 상황
  - 자원 A를 가진 프로세스 P1과 자원 B를 가진 프로세스 P2가 있을 때, P1은 B를 필요로 하고 P2는 A를 필요로 한다면 두 프로세스 P1, P2는 서로 자원을 얻기위해 무한정 기다리게 됨

#### 세마포어(Semaphore)와 뮤텍스(Mutex) 차이

- **뮤텍스**
  - Locking 메커니즘으로 Lock을 걸은 쓰레드만이 임계 영역을 나갈때 락을 해제 가능
- **세마포어**
  - Signaling 메커니즘으로 Lock을 걸지 않은 쓰레드도 Signal을 사용해 락 해제 가능
  - 세마포어의 카운트를 1로 설정하면 뮤텍스처럼 활용 가능

#### OSI 7계층 설명

- 네트워크 상에서 통신이 수행되는 과정을 7단계로 표현
  - 국제표준화기구(ISO) 참여 / 개발
- 전체 과정이 구분된다는 점에서 문제가 생겼을 때 해결 수월함
  - 이상 발생 계층의 장비만 수리 가능, 효과적
- 7 계층 레이어
  - 7. **응용** (Application): HTTP, FTP 프로토콜 활용
      - 사용자와 직접 상호작용하는 응용 프로그램들이 포함된 계층
  - 6. **표현** (Presentation): 데이터의 형식 처리 (이미지, 텍스트)
      - 데이터의 형식(Format)을 정의하는 계층
  - 5. **세션** (Session): 논리적인 연결 (세션) 형성
      - 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층
  - 4. **전송** (Transport): 포트 번호, 응용 프로그램 간 연결 담당
      - 최종 수신 프로세스로 데이터의 전송을 담당하는 계층
  - 3. **네트워크** (Network): IP 주소, 목적지까지 데이터 전달
      - 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층
  - 2. **데이터링크** (Datalink): MAC 주소, 물리 주소 결정
      - 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당하는 계층
  - 1. **물리** (Physical): 랜선, 통신 케이블, 전기 신호 전달
      - 데이터를 전기 신호로 바꾸어주는 계층
- TCP/IP 계층
  - 4. **응용** (Application): OSI 5, 6, 7 계층
  - 3. **전송** (Transport): OSI 4 계층
  - 2. **인터넷** (Internet): OSI 3 계층
  - 1. **네트워크-인터페이스** (Network Interface): OSI 1, 2 계층

#### TCP 연결 / 해제 과정 설명

- TCP
  - 안전, 정확한 데이터 전송 목표
  - 연결 성립: 3Way Handshake
    - *3Way Handshake: TCP 네트워크에서 통신을 하는 장치가 서로 연결이 잘 되었는지 확인하는 방법. 송신자와 수신자는 총 3번에 걸쳐 데이터를 주고 받으며 통신이 가능한 상태임을 확인
    - 클라이언트 => 서버, 연결 목적의 SYN(x) 패킷 전송
    - 서버 => 클라이언트, 확인신호 ACK(x+1), SYN(y) 패킷 전송
    - 클라이언트 => 서버, 확인신호 ACK(y+1) 전송
  - 연결 해제: 4Way Handshake
    - 클라이언트 => 서버, FIN_WAIT_1 상태 유지 + FIN 패킷 전송
    - 서버 => 클라이언트, CLOSE_WAIT 상태 유지 + ACK 패킷 전송
    - 서버, 연결 해제 알림 목적의 FIN 패킷 전송
    - 클라이언트 => 서버, TIME_WAIT 상태 유지 + ACK 패킷 전송
    - TIME_WAIT 시간 만료되면 클라이언트 소켓 닫음

#### TCP/IP 흐름 제어 방법

- 흐름 제어
  - Stop And Wait
  - Sliding Window
- 혼잡 제어
  - AIMD (Additive Increase / Miltiplicative Decrease)
  - Slow Start
  - Fast Recovery

#### TCP와 UDP 통신에 대한 설명

- TCP (Transmission Control Protocol)
  - 연결 지향형
  - 가상 회선 방식
  - 1:1 통신
  - 신뢰 가능한 데이터 전송 지원 프로토콜
  - 3-Way Handshaking 방식 / 연결 해제는 4-Way
  - 패킷의 순서 보장
  - UDP에 비해 상대적으로 전송 속도 느림
  - 흐름 제어: 송신/수신 측의 데이터 처리 속도 차이 조절
  - 혼잡 제어: 패킷 수로 인한 네트워크 Overflow 발생 가능성 조절
  - 수신가능? => 네 => 데이터 보내요 이제 => 데이터 잘 갔나요? => 네
    - 수신 여부 확인
- UDP (User Datagram Protocol)
  - 비연결형, 비신뢰성
  - 데이터그램 방식
  - 1:1, 1:N, N:N 통신
  - 데이터의 경계 구분
  - 패킷 부가적 정보가 적어 (오버헤드 적음) 네트워크 부하 감소
  - 일방적인 데이터 전달
  - 연결 과정 없음, 혼잡제어 과정 없음
  - TCP 보다 속도 빠름
  - 게임 / 실시간 동영상 / 음성 스트리밍에서 주로 사용
  - 데이터 보내요 => 데이터 보내요 => ...

#### 슈퍼키, 후보키, 기본키, 외래키 설명

- 공통: 고유한 식별자 (Identifier)
- 키: 데이터베이스에서 조건에 만족하는 관계의 행을 찾거나 순서대로 정렬할 때 다른 행과 구별할 수 있는 유리한 기준이 되는 속성의 집합
- 종류
  - 슈퍼키
    - 각 행을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합
    - 유일성만 만족하면 가능
      - 하나의 키로 특정 행을 바로 찾아낼 수 있는 고유한 데이터 속성
    - Ex. 주민번호 / 이름 + 나이
  - 후보키
    - 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합
    - 유일성과 최소성 둘 다 만족
  - 기본키
    - 후보키 중에서 하나를 선택한 키
    - 유일성과 최소성 둘 다 만족
    - 오직 1개 지정 가능
    - NULL 값 가질 수 없고 중복된 값 가지는 것이 불가능
  - 대체키
    - 기본키로 지정하고 남은 후보키
  - 외래키
    - 두 개의 테이블을 연결해주는 연결 다리 역할

#### 데이터베이스 정규화와 비정규화의 차이

- 정규화 (Normalization)
  - 데이터 중복 최소화 / 일관성 최대화하도록 설계하는 것
  - 데이터를 분해하는 과정
  - 이상현상 (Anomaly) 방지
    - 삽입 이상
    - 삭제 이상
    - 수정 이상
  - 제 1정규화 (1NF)
  - 제 2정규화
  - 제 3정규화
  - BCNF 정규화
- 비정규화 (반정규화, Denormalization)
  - 읽는 시간을 최적화하도록 설계하는 것
  - 의도적으로 정규화 원칙을 위배하는 행위

#### 데이터베이스 조인 설명

- 한 데이터베이스 내의 여러 테이블의 레코드를 조합하여 하나의 열로 표현하는 것
- 테이블로서 저장되거나 그 자체로 이용할 수 있는 결과 셋을 생성
- 둘 이상의 테이블을 연결해서 테이블을 검색하는 방법

#### 데이터베이스 식별, 비식별 관계 개념 설명

- 식별 관계
  - 부모 테이블의 기본키 또는 유니크 키를 자식 테이블이 자신의 기본키로 사용하는 관계
- 비식별 관계
  - 부모 테이블의 기본키 또는 유니크 키를 자신의 기본키로 사용하지 않고, 외래 키로 사용하는 관계

#### 트랜잭션 설명

- 병행 제어 / 회복 작업 시 처리되는 작업의 논리 단위
- 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위
- 하나의 작업 단위
- 필요한 작은 단위의 코드 위주로 트랜잭션 사용 권장
- 만족시켜야 할 특성
  - 원자성
  - 일관성
  - 격리성
  - 지속성
- Commit
- Rollback
- 상태 전이
  - 활동
  - 부분 완료
  - 완료
  - 실패
  - 취소

#### DBMS 설명

- 데이터베이스에 존재하는 데이터에 접근할 수 있도록 해주는 소프트웨어
- 자바 기반 서버 프로그램에서는 JDBC를 이용해 MySQL에 접근 가능
  - JDBC: Java DataBase Connectivity
- DBMS 를 다루기 위해서는 SQL 이해 필수
  - SQL: Structured Query Language
  - DBMS에 존재하는 데이터 관리를 위한 프로그래밍 언어

#### 관계형 데이터베이스 설명

- RDBMS
- 행과 열이 존재하는 하나이상의 테이블 (릴레이션)
  - 행 = 레코드 = 튜플
  - 열 = 필드 = 속성
- 관계 = 테이블 (같은 속성을 지닌 튜플의 모임)
- Ex. Oracle / MySQL / MSSQL
- 테이블에 따라서 데이터가 분리 / 중복 적음
- 여러 개의 테이블로 구성
- 두 테이블에 대해 특정 키를 기준으로 데이터 조회 가능
  - Primary Key / Foreign Key

#### 테이블 컬럼 컨벤션 설명

- 테이블 이름은 단수형 사용
- 명명 방법은 스네이크 케이스 사용
- 테이블의 키는 "테이블이름\_id" 또는 id

#### 컨텍스트 스위칭 개념

- CPU 에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정
- 인터럽트를 발생시켜 CPU에서 실행 중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정
  - \*인터럽트: CPU가 프로세스를 실행하고 있을 때, 입출력 HW 등의 장치나 예외 상황이 발생하여 처리가 필요함을 CPU에게 알리는 것 의미
- 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태 (Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업
- 스위칭 시 CPU 레지스터 교체 / RAM, CPU 사이의 캐쉬 메모리 데이터 초기화

#### 프로세스 제어 블록

- Process Control Block, PCB
- 프로세스에 대한 중요한 정보를 저장하고 있는 OS의 자료구조
- OS는 프로세스 관리를 위해 프로세스의 생성과 동시에 고유한 PCB를 생성
- 저장되는 정보
  - PID
  - 프로세스 상태
  - 프로그램 카운터 (다음에 실행할 명령어의 주소)
  - CPU 레지스터
  - CPU 스케쥴링 정보 (우선순위, 스케쥴 큐에 대한 포인터)
  - 메모리 관리 정보
  - 입출력 관리 정보 (할당된 입출력 장치들과 열린 파일 목록)
  - 어카운팅 정보 (사용된 CPU 시간, 시간제한, 계정번호)

#### RESTful API 설명

- REST(REpresentational State Transfer)ful API는 HTTP 통신에서 어떤 자원에 대한 CRUD 요청을 Resource와 Method로 표현하여 특정한 형태로 전달하는 방식
- 구성 요소
  - Resource(자원, URI)
  - Method(요청 방식, GET or POST 등)
  - Representation of Resource(자원의 형태, JSON or XML 등)

#### 함수형 프로그래밍 특징 설명

- immutable data와 first class citizen으로서의 함수
- 부수효과가 없는 순수 함수를 이용하여 프로그램을 만드는 것
  - 부수 효과가 없는 순수 함수란 데이터의 값을 변경시키지 않으며 객체의 필드를 설정하는 등의 작업을 하지 않는 함수를 의미

#### 메모리 구조 설명

- 코드 영역: 실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 부름
  - 사용자가 프로그램 실행 명령을 내리면 OS가 HDD에서 메모리로 실행 코드를 올리게 되고, CPU는 코드 영역에 저장된 명령어를 하나씩 처리하게 됨.
- 데이터 영역: 프로그램의 전역 변수(global)와 정적 변수(static)가 저장되는 영역
  - 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸함
- 힙 영역: 프로그래머가 직접 관리할 수 있는 메모리 영역으로 이 공간에 메모리를 할당하는 것을 동적 할당이라 함
  - Java에서는 가비지 컬렉터가 자동으로 해제해줌
  - 힙 영역은 스택 영역과 달리 낮은 주소에서 높은 주소로 메모리가 할당됨
- 스택 영역: 함수의 호출과 함께 할당되며 지역 변수와 매개 변수가 저장되는 영역
  - 스택 영역에 저장되는 함수의 호출 정보를 스택프레임이라고 함
  - 스택 영역은 함수의 호출이 완료되면 소멸
  - 스택 영역은 높은 주소에서 낮은 주소로 메모리가 할당

#### 프레임워크와 라이브러리 차이

- 라이브러리: 사용자가 흐름에 대한 제어를 하며 필요한 상황에 가져다가 쓸 수 있음
- 프레임워크: 전체적인 흐름을 자체적으로 제어함
- 추가 설명
  - 프레임워크와 라이브러리는 실행 흐름에 대한 제어 권한이 어디 있는지에 따라 달라짐
  - 프레임워크를 사용하면 사용자가 관리해야 하는 부분을 프레임워크에 넘김으로써 신경써야 할 것을 줄이는 제어의 역전(IoC, Inversion Of Control)이 적용됨

#### 병렬 처리 프레임워크의 종류와 특징

- Hadoop
  - HDFS(Hadoop Distributed File System)를 활용해 데이터를 주고 받음
  - 데이터가 여러 노드에 분산되어 저장되기 때문에 손실의 우려가 없다는 장점이 있음
    - File I/O를 기반으로 작동하기 때문에 처리 속도가 느림
- Spark
  - In-Memory 상에서 데이터를 주고받고 연산을 수행
  - 메모리를 사용해 데이터를 처리하기 때문에 Hadoop보다 속도가 약 100배 정도 빠름
    - 메모리상에서 처리하기 때문에 장애가 발생한 경우 응용 프로그램을 처음부터 다시 시작해야 하는 단점이 있음

#### Call By Value와 Call By Reference 차이

- Call By Value
  - 인자로 받은 값을 복사하여 처리하는 방식
  - Call By Value에 의해 넘어온 값을 증가시켜도 원래의 값이 보존됨
  - 값을 복사하여 넘기기 때문에 메모리 사용량이 늘어남
- Call By Reference
  - 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 주는 방식
  - 값을 복사하지 않고 직접 참조하기 때문에 속도가 빠름
  - 원래의 값에 영향을 주는 리스크 존재

#### 메세지 큐(Message Queue) 설명

- Queue 자료구조를 이용하여 데이터(메세지)를 관리하는 시스템
- 비동기 통신 프로토콜을 제공하여 메세지를 빠르게 주고 받을 수 있게 해줌
- Producer(생산자)가 Message를 Queue에 넣어두면, Consumer가 Message를 가져와 처리
  - 생산자는 메세지를 큐에 쌓고 소비자는 메세지를 꺼내어 처리
- 대표적 시스템 예: Kafka, Rabbit MQ, AMPQ 등

#### Docker(도커)와 Kubernates(쿠버네티스) 설명

- Docker는 컨테이너 기반의 가상화 기술
- 기존에는 하드웨어를 가상화하였기 때문에 Host OS 위에 Guest OS를 설치해야 되서 무겁고 느려 한계가 많이 존재
- 이를 극복하고자 프로세스를 격리시킨 컨테이너를 통해 가상화를 하는 Docker(도커)와 같은 기술들이 등장
- 도커를 통해 구동되는 컨테이너를 관리하기 위한 Kubernates(쿠버네티스)가 등장
- 쿠버네티스는 도커 컨테이너를 관리하기 위한 기술

#### Docker(도커)의 장/단점 설명

- 장점
  - 쉽고 빠른 실행 환경 구축
  - 하드웨어 자원 절감
  - Docker Hub와 같은 공유 환경 제공
- 단점
  - 개발 초기의 오버헤드 / 러닝커브
  - Linux 친화적

#### TDD(Test-Driven Development) 설명

- 매우 짧은 개발 사이클의 반복에 의존하는 개발 프로세스
- 개발자는 우선 요구되는 기능에 대한 테스트케이스를 작성하고, 그에 맞는 코드를 작성하여 테스트를 통과한 후에 상황에 맞게 리팩토링하는 테스트 주도 개발 방식
- 개발자는 테스트를 작성하기 위해 해당 기능의 요구사항을 확실히 이해해야 함
- TDD 개발 방식은 개발자가 개발 전에 요구사항에 집중할 수 있도록 도와주지만 테스트를 위한 진입 장벽과 작성해야 하는 코드의 증가는 단점, 적당한 절충안이 필요
  - TDD 베이스로 업무를 진행하되 요구사항 기능을 줄일려고 노력하거나 테스트 코드 작성의 경계치를 설정하는 방향으로 절충 시도

#### DDD(Domain-Driven Design) 설명

- 실세계에서 사건이 발생하는 집합인 Domain(도메인)을 중심으로 설계하는 방법
- 옷 쇼핑몰을 예로 들면 손님들이 주문하는 도메인, 점주들이 관리하는 도메인 등이 있을 수 있는데 이러한 도메인들이 서로 상호작용하며 설계하는 것이 도메인 주도 설계
- 도메인 주도 설계에서 도메인은 각각 분리되어 있는데, 이러한 관점에서 MSA(MicroService Architecture)를 적용하면 용이한 설계가 가능
- DDD에서는 같은 객체들이 존재할 수 있는데, 예를 들어 옷 구매자의 입장에서는 (name, price)와 같은 객체 정보를 담지만, 판매자의 입장에서는(madeTie, size, madeCountry) 등이 있을 수 있음. 즉, 문맥에 따라 객체의 역할이 바뀔 수 있는 것이 DDD

#### MSA(Micro Service Architecture) 설명 및 장/단점 나열

- 모든 시스템의 구성요소가 한 프로젝트에 통합되어 있는 Monolithic Architecture(모놀리식 아키텍쳐)의 한계점을 극복하고자 등장
- MSA는 1개의 시스템을 독립적으로 배포가능한 각각의 서비스로 분할
- 각각의 서비스는 API를 통해 데이터를 주고받으며 1개의 큰 서비스를 구성
- 장점
  - 일부 서비스에 장애가 발생하여도 전체 서비스에 장애가 발생하지 않음
  - 각각의 서비스들은 서로 다른 언어와 프레임워크로 구성 가능
  - 서비스의 확장이 용이
- 단점
  - 서비스가 분리되어 있어, 테스팅이나 트랜잭션 처리 등이 어려움
  - 서비스 간에 API로 통신하기 때문에 그에 대한 비용 발생
  - 서비스 간의 호출이 연속적이기 때문에 디버깅 및 에러 트레이싱이 어려움

#### 대칭키 (Symmetric-Key)와 공개키 (Public-Key) 암호화 방식 차이 설명

- 대칭키 암호화 방식
  - 암/복호화에 사용하는 키가 동일한 암호화 방식
  - 대칭키는 암/복호화키가 동일하므로 해당 키를 아는 사람이 문서를 복호화 가능
  - 대표적인 알고리즘: DES, 3DES, AES, SEED, ARIA 등
  - 공개키 암호화 방식에 비해 연산 속도가 빠르다는 장점
  - 키를 교환해야 하는 문제가 발생
  - 키를 교환하는 중 키 탈취 가능성 존재
  - 사용자가 증가할수록 각각의 키가 필요하기에 관리해야 할 키가 방대하게 증가되는 문제 존재
  - 대칭키 단점 보완을 위해 키의 사전 공유, 키 배포 센터 사용, Diffie-Hellman 키 교환, 공개키 암호화 방식 등이 존재
- 공개키 암호화 방식
  - 암복호화에 사용하는 키가 서로 다른 암호화 방식 (비대칭키 암호화)
  - 공개키 암호화 방식은 효율은 떨어지지만, 대칭키 암호화 방식의 키를 교환해야 하는 문제를 해결하기 위해 등장
  - 대표적인 알고리즘: Diffie-Hellman, RSA, DSA, ECC 등
  - A가 B에게 데이터를 보낸다고 할 때, A는 B의 공개키로 데이터를 암호화해서 보내고 B는 본인의 개인키로 해당 암호화된 데이터를 복호화해서 보게 됨
  - 암호화된 데이터는 B의 공개키에 대응되는 개인키를 갖고 있는 B만이 볼수 있음
  - 공개키는 키가 공개되어 있기 때문에 따로 키 교환이나 분배를 할 필요가 없음
  - 중간 공격자가 B의 공개키를 얻는다고 해도 B의 개인키로만 복호화가 가능
  - 키 전달 문제를 해결하여 더 안전하지만, 암호화와 복호화를 위해 복잡한 수학 연산을 수행하기 때문에 대칭키 알고리즘에 비해 속도가 느리다는 단점

#### 함수 설명

- 특정한 목적을 수행하기 위해 독립적으로 짜여진 코드의 집합

<<<<<<< Updated upstream
#### 웹 동작 방식 설명

- 사용자가 브라우저에 URL을 입력
- 브라우저는 DNS를 통해 서버의 진짜 주소를 찾음
- HTTP 프로토콜을 사용하여 HTTP 요청 메세지를 생성함
- TCP/IP 연결을 통해 HTTP요청이 서버로 전송됨
- 서버는 HTTP 프로토콜을 활용해 HTTP 응답 메세지를 생성함
- TCP/IP 연결을 통해 요청한 컴퓨터로 전송
- 도착한 HTTP 응답 메세지는 웹페이지 데이터로 변환되고, 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 됨

#### 공인 IP와 사설 IP 차이 설명
 
- 공인 IP
  - 전세계에서 유일한 IP로 ISP(인터넷 서비스 공급자)가 제공하는 IP주소
  - 외부에 공개되어 있기 때문에 인터넷에 연결된 다른 장비로부터 접근이 가능
  - 방화벽 등과 같은 보안 설정을 해주어야 한다.
- 사설 IP
  - 어떤 네트워크 안에서 사용되는 IP주소
  - IPV4의 부족으로 인해 모든 네트워크가 공인 IP를 사용하는 것이 불가능하기 때문에 네트워크 안에서 라우터를 통해 할당받는 가상의 주소
  - 별도의 설정 없이는 외부에서 접근이 불가능

#### 웹 접근성의 국제표준 설명

- 웹 접근성을 높이기 위해 고안된 웹 표준은 웹에서 표준적으로 사용되는 기술이나 규칙을 의미
- 웹 표준을 정하기 위하 W3C(World Wide Web Consortium)이 설립되었으며 웹 표준으로 구조 언어인 HTML, 표현 언어인 CSS, 동작 언어인 Script를 지정

#### 세마포어(Semaphore)와 뮤텍스(Mutex) 차이

- 뮤텍스
  - Locking 메커니즘으로 락을 걸은 쓰레드만이 임계 영역을 나갈때 락을 해제 가능
- 세마포어
  - Signaling 메커니즘으로 락을 걸지 않은 쓰레드도 signal을 사용해 락을 해제 가능
  - 세마포어의 카운트를 1로 설정하면 뮤텍스처럼 활용 가능
=======
#### 앱 설치를 위한 QR 코드 생성 관련 지식

- 안드로이드 & 아이폰 모두 하나의 QR로 제작 가능
  - 각각 따로 제작하는 것도 가능
  - QR 생성 때 설정 부분에서 Android, iOS 앱 스토어 관련 URL을 각각 설정 가능
- 앱 설치 유무에 따라 앱으로 이동 또는 앱 스토어로 이동하는 기능
  - 불가능
  - 제한적으로는 가능
    - 개발자가 카메라 모듈 기능을 가지고 특정앱을 제작하고 그 특정 앱에서 QR 기능을 커스터마이징 할 수 있으면 가능할 것으로 판단됨.

#### Byte Ordering 설명

- 데이터가 저장되는 순서를 의미
- 빅엔디안(Big Endian)과 리틀엔디안(Little Endian) 방식 존재
- Big Endian
  - MSB (Most Significant Byte)가 가장 낮은 주소에 위치하는 저장 방식
  - 네트워크에서 데이터를 전송할 때 주로 사용됨
  - 가장 낮은 주소에 MSB가 저장되므로, offset=0인 Byte를 보면 양수/음수를 바로 파악 가능
- Little Endian
  - MSB가 가장 높은 주소에 위치하는 방식
  - 마이크로프로세서에서 주로 사용
  - 가장 낮은 주소에 부호값이 아닌 데이터가 먼저 오기 때문에, 바로 연산 가능
>>>>>>> Stashed changes
