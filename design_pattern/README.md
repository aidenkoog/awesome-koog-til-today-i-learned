#### 디자인 패턴 (Design Pattern) 개념

- 배경
  - 소프트웨어를 재사용 가능하고 유연, 확장성있고 유지보수가 용이하게 만드는 것은 어려운 일
  - 패턴 없는 개발 후 유지보수 비용이 더 들게되는 상황 발생
  - 기술, 창의성 등도 중요하나 경험이 가장 중요하다는 관점
- 개념
  - 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴
  - 개발 효율성, 유지보수성 그리고 운용성이 높아지고 프로그램 최적화에 도움

#### 디자인 패턴 유형 설명

- 목적
  - 생성: 객체 인스턴스 생성하는 패턴
    - 클래스
      - Factory Method
    - 오브젝트
      - Absract Factory
      - Builder
      - Prototype
      - Singleton
  - 구조: 클래스와 객체를 더 큰 구조로 만들 수 있게 구성을 사용하는 패턴
    - 클래스
      - Adapter (class)
    - 오브젝트
      - Adapter (object)
      - Bridge
      - Decorator
      - Facade
      - Flyweight
      - Proxy
      - Composite
  - 행위: 클래스와 객체들이 상호작용하는 방법과 역할을 분담하는 방법을 다루는 패턴
    - 클래스
      - Interpreter
      - Temp₩late Method
    - 오브젝트
      - Chain of Responsibility
      - Command
        - 특정 기능 / 요청들을 캡슐화 시키는 패턴
      - Iterator
      - Mediator
      - Memento
      - Observer
      - State
      - Strategy
      - Visitor
- 범위
  - 클래스
  - 객체

#### 디자인 패턴 적용의 필요성

- 규칙은 아니나 재사용성, 유연성, 확장성, 모듈화 작업을 향상
- 소프트웨어 개발 자체 커뮤니케이션에 도움
- 높은 결합도나 종속적으로 구현된 소프트웨어의 리팩토링을 가능하게 함
  - 잘못 설계된 소프트웨어 개선 작업에 도움
- 좋은 설계를 유도하며 유지보수에 들어가는 비용 절약 가능

#### Observer 패턴 설명

- 어떤 이벤트가 일어나는 것을 감시하여 특정 이벤트 발생 시 어떠한 동작을 즉각 수행하게 해줌
- 다른 객체의 상태 변화를 별도의 함수 호출 없이 즉각적으로 알 수 있어 효율적인 프로그래밍 가능

#### 객체지향 프로그래밍과 객체지향 설계

- 추상화
  - 처리과정 / 데이터 구조, 표현 방법 추상화
  - 속성 또는 기능 추출하는 작업
- 캡슐화
  - information hiding
  - 단순한 접근을 제공하여 오류가 생길 부분을 감소
  - 클라이언트 코드가 세부적인 사항을 알 필요 없음
- 상속성
  - 일반적인 객체와 구체적인 개념의 객체 관계 표현 (General <-> Specific)
  - 상위 클래스의 타입을 내포
  - 단순 코드의 재사용 목적이 아님
  - 상위 클래스의 속성과 기능을 하위 클래스에서 사용 또는 재정의 가능
- 다형성 (polymorphism)
  - 같은 메세지, 구현에 대해 각 객체가 다른 표현과 결과를 나타내는 것
  - 클래스의 상속, 인터페이스의 구현 시 각각의 다른 구현을 가진 클래스들이 상위 타입으로 업캐스팅
  - 오버라이딩한 메소드가 존재할 시 같은 상위 타입으로 선언된다 하더라도 각기 다른 인스턴스의 메소드가 호출되는 것
  - 예. 인터페이스 타입의 변수에 그 인터페이스를 구현한 클래스를 대입하는 것
  - 자바의 경우 모든 메소드가 가상함수 기반으로 구현되므로 하위 클래스에 재정의된 메소드가 있는 경우 그 메소드가 호출됨
    - C++의 경우 virtual function 만이 재정의된 함수가 호출
- 객체 지향 설계
  - Design Heuristics
    - (참고) Heuristic: 경험에 기반하여 어떤 문제를 해결, 학습 또는 발견해내는 방법
    - 추상 클래스, 구체 클래스
    - 클래스 상속 또는 합성
    - 인터페이스 상속, 구현체 상속
- 응집도
  - 하나의 모듈, 객체 내부의 요소들 간의 연관성
  - 하나의 책임을 구현하는 하나의 객체는 높은 응집도
- 결합도
  - 객체 상호 간의 연관 관계
  - 결합도가 높으면 하나의 객체를 수정할 때 다른 객체도 수정 필요

#### OOP의 5가지 설계 원칙 설명 (SOLID)

- SRP(Single Responsibility Principle, 단일 책임 원칙)
  - 클래스는 단 하나의 목적을 가져야 하며, 클래스를 변경하는 이유는 단 하나의 이유여야 함
  - 한 클래스에서 여러 기능을 제공하게 되면 유지보수가 어려움
- OCP(Open-Closed Principle, 개방 폐쇠 원칙)
  - 클래스는 확장에는 열려 있고, 변경에는 닫혀 있어야 함
  - 객체 자신의 수정에 대해서는 유연하고, 다른 클래스가 수정될 때는 영향을 받지 않음
  - 인터페이스나 추상 클래스를 통해 접근하도록 유도
  - 예) 자바 JDBC, I/O Stream
    - 여러 종류의 DB 가 있다고 가정 => JDBC에는 인터페이스가 정의되어 있음 => 그 인터페이스들에 대한 구현을 각각의 회사의 데이터베이스 로직에서 구현을 함
    - Client DAO 단만 수정하면 됨 (Client DAO ==> JDBC ==> Database)
    - I/O Stream 예: InputStream ==> File / Network / Etc
- LSP(Liskov Substitution Principle, 리스코프 치환 원칙)
  - 상위 타입의 객체를 하위 타입으로 바꾸어도 프로그램은 일관되게 동작해야 함
  - 하위 클래스는 항상 상위 클래스로 교체될 수 있어야 함
    - 하위 클래스는 오버라이드든 오버로딩의 형태든 모든 정보를 가질 수 있어야 함.
  - 즉, 상위 클래스에 제공되는 여러 기능은 하위 클래스가 모두 사용가능 해야 함
  - IS-A 관계 (is a kind of 관계)
- ISP(Interface Segregation Principle, 인터페이스 분리 원칙)
  - 클라이언트는 이용하지 않는 메소드에 의존하지 않도록 인터페이스를 분리해야 함
  - 제공하는 기능에 대한 인터페이스에만 종속적이어야 함
  - 하나의 객체가 여러 기능을 제공할 수 밖에 없다면 (단일 책임 원칙에 위배되는 상황) 클라이언트가 사용할 수 있는 여러 인터페이스로 분리하여 제공하면 클라이언트가 사용하지 않는 기능에 종속적이지 않을 수 있음
  - 예) I-a, I-b, I-c <-- A class 구조일 때 I-a 의 기능을 사용하고 싶으면 I-a obj = new A(); 의 형태로 필요한 인터페이스만 사용 가능
- DIP(Dependency Inversion Principle, 의존 역전 법칙)
  - 클라이언트는 추상화(인터페이스)에 의존해야 하며, 구체화(구현된 클래스)에 의존해선 안됨.
  - 의존 관계는 구체적인 것 보다는 추상적인 것에 의존 (추상클래스 또는 인터페이스로 의존해야 함)
  - 구체적인 것은 이미 구현이 되어 있고 변하기 쉬운 것
  - 추상적인 것은 인터페이스나 추상 클래스 (상위 클래스)
