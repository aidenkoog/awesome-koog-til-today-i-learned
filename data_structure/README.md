#### 자료구조 (Data Structure) 개념

- 데이터 값의 모임
- 자료의 집합
- 각 원소들이 논리적으로 정의된 규칙에 의해 나열되며 자료에 대한 처리를 효율적으로 수행할 수 있도록 자료를 구분하여 표현한 것
- 메모리 공간을 효율적으로 사용해야 하는데에 필요한 것
- 자료구조는 데이터를 원하는 규칙 또는 목적에 맞게 저장하기 위한 구조
  - 알고리즘이란 자료구조에 쌓인 데이터를 활용해 어떠한 문제를 해결하기 위한 여러 동작들의 모임

#### 자료구조의 종류

- 단순 구조
  - 정수, 실수, 문자, 문자열
- 선형 구조
  - 배열, 연결리스트, 스택, 큐
- 비선형 구조
  - 트리, 그래프

#### 자료구조에서 암호화하는 방법 설명

- 해싱 (허프만 코드)
- 실제 활용 예시
  - 대칭키
  - 공개키
  - 비밀번호
  - HTTPS
- 대칭키와 공개키에 대한 설명
  - 암호화 키, 복호화 키
- 해싱에서 효율적으로 암호화하는 방식
  - 해시함수 (해시 충돌) SHA-256
- HTTPS의 암호화는 진행 방식
  - 세션키, 인증서

#### 해시 설명

- 해시함수를 통해 임의의 난수를 만드는 것
- A라는 문자열을 해시함수를 통해 B라고 만들었을 때 이 B를 가지고 A를 유추할 수 없게 하는 것
  - B를 데이터베이스에 저장
  - A라는 같은 값을 입력했을 때 해시함수를 돌리면 B가 출력
  - 이 값을 데이터베이스에 있는 값과 비교
- 단방향 암호화
- 암호화는 A -> B -> A (복호화를 통해 다시 A를 알아낼 수 있음)
- 예시
  - 해시: SHA256
  - 암호화: RSA

#### 백만명/천만명 이상의 특정 정보 노티피케이션과 저장 방법 설명

- 메세지큐에 담아 각각의 여러 서버에서 병렬 처리
- 그냥 데이터를 저장하게 되면 모든 테이블을 살펴야 하는 문제점 발생
  - 비효율, 저장용량 증가
- Key: Value list 형식으로 저장
  - 이미 있는 데이터를 다시 Write 해야 되는 단점

#### 2개의 큐로 스택 구현 과정

- 메인 / 서브 큐로 구성
- 원래 서브 큐안에 1이라는 데이터가 있었다고 가정
- 메인 큐에 데이터 입력되는 시점에 원래 메인 큐에 있던 데이터들을 서브 큐로 이동
  - 메인: 0, 서브: 1
- 메인 큐에 데이터 입력 완료
  - 메인: 2, 서브: 1
- 서브 큐안의 데이터들을 메인 큐로 이동
  - 메인 1, 2, 서브: 0

#### 2개의 스택으로 큐 구현 과정

- Stack1은 data를 넣는 용도로만 쓰고, Stack2는 data를 빼는 용도로만 사용
- Stack1로는 data를 입력 받음
  - 1, 2, 3 데이터 입력, 아래부터 1 => 2 => 3 순으로 적재
- Stack2에서는 data를 pop
  - 이전에 존재하였던 데이터를 pop
- Stack2가 비어 있다면 Stack1에서 Stack2로 data를 이동
  - 스택 1에서 하나씩 이동, 아래부터 3 => 2 => 1 순으로 적재

#### 해시맵과 트리맵의 차이점

- 해시맵
  - 해시 이용한 저장을 하므로 순서 보장이 안됨
  - 해시 이용하여 배열에 접근 가능 O(1)
- 트리맵
  - Entry를 트리 형태로 저장하여 저장할 때 키 값을 기준으로 자동으로 정렬되어 저장
  - 트리 구조의 특성상 특정 Entry에 접근하기 위해서는 O(logn)

#### Array와 ArrayList 차이

- Array
  - 초기화 시 배열 사이즈 고정
  - 초기화 시 메모리에 할당되어 ArrayList보다 속도 빠름
  - 사이즈 변경 불가
  - 다차원 배열 가능
- ArrayList
  - 가변적인 크기
  - 데이터 추가 / 삭제 시 메모리를 재할당하므로 속도가 Array 보다 느림
  - 추가 / 삭제 가능
  - 다차원 배열 사용 불가능

#### LinkedList와 ArrayList 차이

- ArrayList
  - ArrayList는 데이터들이 순서대로 늘어선 배열의 형식
  - 원하는 데이터에 무작위로 접근 가능
  - 리스트의 크기가 제한되어 있으며, 리스트의 크기를 재조정하는 것은 많은 연산이 필요
  - 데이터의 추가/삭제를 위해서는 임시 배열을 생성하여 복제하고 있어 시간이 오래 걸림
- LinkedList
  - LinkedList는 자료의 주소값으로 서로 연결된 형식
  - 리스트의 크기에 영향 없이 데이터를 추가 가능
  - 데이터를 추가하기 위해 새로운 노드를 생성하여 연결하므로 추가/삭제 연산이 빠름
  - 무작위 접근이 불가능하며, 순차 접근만 가능

#### AVL 트리 설명

- 한 쪽으로 값이 치우치는 이진 탐색 트리(Binary Search Tree, BST)의 한계점을 보완하기 위해 만들어진 균형 잡힌 이진 트리
- 항상 좌/우로 데이터를 균형잡힌 상태로 유지하기 위해 추가적인 연산을 진행

#### 레드블랙 트리 설명

- 레드블랙 트리는 모든 노드를 빨간색 또는 검은색으로 색칠
- 연결된 노드들은 색이 중복되지 않도록 관리됨

#### 스택, 큐, 트리, 힙 구조 설명

- 스택: 세로로 된 바구니와 같은 구조로 먼저 넣게 되는 자료가 마지막으로 나오게 되는 First-In Last-Out(FILO) 구조
- 큐: 가로로 된 통과 같은 구조로 먼저 넣게 되는 자료가 가장 먼저 나오는 First-In First-Out(FIFO) 구조
- 트리: 정점과 간선을 이용해 사이클을 이루지 않도록 구성한 Graph의 특수한 형태
  - 계층이 있는 데이터를 표현하기에 적합
- 힙: 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조
  - 각 노드의 키값이 자식의 키값보다 작지 않거나(최대힙) 그 자식의 키값보다 크지 않은(최소힙) 완전이진트리

#### 우선순위 큐와 내부 구조 및 시간복잡도 설명

- 우선순위 큐는 가장 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조
- 우선순위 큐를 구현하기 위해서 일반적으로 힙을 사용
- 힙은 완전이진트리를 통해서 구현되었기 때문에 우선순위 큐의 시간복잡도는 O(logn)

#### 해시 테이블 / 시간 복잡도 설명

- (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용
- Key값에 해시함수를 적용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조
- 고유한 index로 값을 조회하기 때문에 평균적으로 O(1)의 시간복잡도 유지
- 해시의 index값이 충돌이 발생한 경우 충돌된 index값에 대해 연결된 데이터들을 조회하여 원하는 값을 조회하기 때문에 O(N)까지 증가 가능성 존재