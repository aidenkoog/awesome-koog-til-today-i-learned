#### 자료구조 (Data Structure) 개념

- 데이터 값의 모임
- 자료의 집합
- 각 원소들이 논리적으로 정의된 규칙에 의해 나열되며 자료에 대한 처리를 효율적으로 수행할 수 있도록 자료를 구분하여 표현한 것
- 메모리 공간을 효율적으로 사용해야 하는데에 필요한 것
- 자료구조는 데이터를 원하는 규칙 또는 목적에 맞게 저장하기 위한 구조
  - 알고리즘이란 자료구조에 쌓인 데이터를 활용해 어떠한 문제를 해결하기 위한 여러 동작들의 모임

#### 자료구조의 종류

- 단순 구조
  - 정수, 실수, 문자, 문자열
- 선형 구조
  - 배열, 연결리스트, 스택, 큐
- 비선형 구조
  - 트리, 그래프

#### 자료구조에서 암호화하는 방법 설명

- 해싱 (허프만 코드)
- 실제 활용 예시
  - 대칭키
  - 공개키
  - 비밀번호
  - HTTPS
- 대칭키와 공개키에 대한 설명
  - 암호화 키, 복호화 키
- 해싱에서 효율적으로 암호화하는 방식
  - 해시함수 (해시 충돌) SHA-256
- HTTPS의 암호화는 진행 방식
  - 세션키, 인증서

#### 해시 (Hash) 설명

- 해시함수를 통해 임의의 난수를 만드는 것
- A라는 문자열을 해시함수를 통해 B라고 만들었을 때 이 B를 가지고 A를 유추할 수 없게 하는 것
  - B를 데이터베이스에 저장
  - A라는 같은 값을 입력했을 때 해시함수를 돌리면 B가 출력
  - 이 값을 데이터베이스에 있는 값과 비교
- 단방향 암호화
- 암호화는 A -> B -> A (복호화를 통해 다시 A를 알아낼 수 있음)
- 예시
  - 해시: SHA256
  - 암호화: RSA

#### 백만명/천만명 이상의 특정 정보 노티피케이션과 저장 방법 설명

- 메세지큐에 담아 각각의 여러 서버에서 병렬 처리
- 그냥 데이터를 저장하게 되면 모든 테이블을 살펴야 하는 문제점 발생
  - 비효율, 저장용량 증가
- Key: Value list 형식으로 저장
  - 이미 있는 데이터를 다시 Write 해야 되는 단점

#### 2개의 큐로 스택 구현 과정

- 메인 / 서브 큐로 구성
- 원래 서브 큐안에 1이라는 데이터가 있었다고 가정
- 메인 큐에 데이터 입력되는 시점에 원래 메인 큐에 있던 데이터들을 서브 큐로 이동
  - 메인: 0, 서브: 1
- 메인 큐에 데이터 입력 완료
  - 메인: 2, 서브: 1
- 서브 큐안의 데이터들을 메인 큐로 이동
  - 메인 1, 2, 서브: 0

#### 2개의 스택으로 큐 구현 과정

- Stack1은 data를 넣는 용도로만 쓰고, Stack2는 data를 빼는 용도로만 사용
- Stack1로는 data를 입력 받음
  - 1, 2, 3 데이터 입력, 아래부터 1 => 2 => 3 순으로 적재
- Stack2에서는 data를 pop
  - 이전에 존재하였던 데이터를 pop
- Stack2가 비어 있다면 Stack1에서 Stack2로 data를 이동
  - 스택 1에서 하나씩 이동, 아래부터 3 => 2 => 1 순으로 적재

#### 해시맵 (HashMap)과 트리맵 (TreeMap)의 차이점

- 해시맵
  - 해시 이용한 저장을 하므로 순서 보장이 안됨
  - 해시 이용하여 배열에 접근 가능 O(1)
- 트리맵
  - Entry를 트리 형태로 저장하여 저장할 때 키 값을 기준으로 자동으로 정렬되어 저장
  - 트리 구조의 특성상 특정 Entry에 접근하기 위해서는 O(logn)

#### Array와 ArrayList 차이

- Array
  - 초기화 시 배열 사이즈 고정
  - 초기화 시 메모리에 할당되어 ArrayList보다 속도 빠름
  - 사이즈 변경 불가
  - 다차원 배열 가능
- ArrayList
  - 가변적인 크기
  - 데이터 추가 / 삭제 시 메모리를 재할당하므로 속도가 Array 보다 느림
  - 추가 / 삭제 가능
  - 다차원 배열 사용 불가능

#### LinkedList와 ArrayList 차이

- ArrayList
  - ArrayList는 데이터들이 순서대로 늘어선 배열의 형식
  - 원하는 데이터에 무작위로 접근 가능
  - 리스트의 크기가 제한되어 있으며, 리스트의 크기를 재조정하는 것은 많은 연산이 필요
  - 데이터의 추가/삭제를 위해서는 임시 배열을 생성하여 복제하고 있어 시간이 오래 걸림
- LinkedList
  - LinkedList는 자료의 주소값으로 서로 연결된 형식
  - 리스트의 크기에 영향 없이 데이터를 추가 가능
  - 데이터를 추가하기 위해 새로운 노드를 생성하여 연결하므로 추가/삭제 연산이 빠름
  - 무작위 접근이 불가능하며, 순차 접근만 가능

#### Array와 LinkedList 장/단점

- Array
  - 데이터에 접근하기 위한 인덱스가 존재
  - 인덱스로 원소에 접근 가능해서 찾고자 하는 원소의 인덱스 값을 알고 있으면 O(1)의 성능으로 접근 가능
  - Random Access 가능하여 속도 빠름
  - 추후 데이터가 삭제되는 경우 배열의 빈 부분의 메모리가 낭비
  - 정의와 동시에 길이를 지정하며 길이를 바꿀 수 없는 정적 자료형
  - 삽입 / 삭제 과정에서 각 원소들에 대한 shift 처리 비용 발생하므로 이런 경우에는 O(n)의 시간 복잡도 형성
  - 정리: 검색 빠르나 삽입/삭제 느림
- LinkedList
  - 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있기 때문에 이 부분만 다른 값으로 변경해주면 삽입과 삭제를 O(1)로 해결 가능
  - 원하는 위치에 한번에 접근 불가능, 원하는 원치를 검색하는 과정에 있어서 1번째 원소부터 다 확인해야 하는 문제 발생
  - 삽입/삭제 빠르나 검색 느림
  - 빈틈없이 데이터를 적재하는 장점을 취한 자료형
  - 순서가 있으며 중복이 허용
  - 자동으로 엘리먼트를 수용할 수 있는 크기가 조정되고, 리스트 내의 엘리먼트의 실제 개수를 얄려줌
  - List 대표적인 기능
    - 처음, 끝, 중간에 엘리먼트를 추가/삭제 하는 기능
    - 리스트에 데이터가 있는지를 체크하는 기능
    - 리스트의 모든 데이터에 접근할 수 있는 기능

#### BST(이진 탐색 트리, Binary Search Tree)와 이진 트리 (Binary Tree) 에 대한 설명

- 이진 트리
  - 자식 노드가 최대 2개인 노드들로 구성된 트리
- 이진 탐색 트리
  - 이진 탐색 + 연결 리스트 결합한 자료구조
  - 이진 탐색의 효율적인 탐색 능력 유지, 빈번한 입력 / 삭제 가능
  - 왼쪽 트리의 모든 값은 반드시 부모 노드보다 작아야 하고, 오른쪽 트리의 값은 부모 노드보다 커야 하는 특징
  - 트리 높이에 영향
  - 높이가 h일 때 O(h)의 시간 복잡도 형성
  - 트리의 균형이 한쪽으로 치우친 경우 최악의 경우가 되고 O(n)의 시간 복잡도 형성
    - 이를 극복하기 위해 나온 기법 => RBT(Red-Black Tree)

#### AVL 트리 설명

- 한 쪽으로 값이 치우치는 이진 탐색 트리(Binary Search Tree, BST)의 한계점을 보완하기 위해 만들어진 균형 잡힌 이진 트리
- 항상 좌/우로 데이터를 균형잡힌 상태로 유지하기 위해 추가적인 연산을 진행

#### 레드블랙 (RBT, Red-Black Tree) 트리 설명

- BST 이진 탐색 트리를 기반으로 하는 트리 형식 자료 구조
- 노드의 child가 없는 경우 child를 가리키는 포인터는 NIL 값을 저장하고 이러한 NIL들을 leaf node로 간주
- 레드블랙 트리는 모든 노드를 빨간색 또는 검은색으로 색칠
- 연결된 노드들은 색이 중복되지 않도록 관리됨

#### 스택, 큐, 트리, 힙 구조 설명

- 스택: 세로로 된 바구니와 같은 구조로 먼저 넣게 되는 자료가 마지막으로 나오게 되는 First-In Last-Out(FILO) 구조
- 큐: 가로로 된 통과 같은 구조로 먼저 넣게 되는 자료가 가장 먼저 나오는 First-In First-Out(FIFO) 구조
- 트리: 정점과 간선을 이용해 사이클을 이루지 않도록 구성한 Graph의 특수한 형태
  - 계층이 있는 데이터를 표현하기에 적합
- 힙: 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조
  - 각 노드의 키값이 자식의 키값보다 작지 않거나(최대힙) 그 자식의 키값보다 크지 않은(최소힙) 완전이진트리

#### 우선순위 큐와 내부 구조 및 시간복잡도 설명

- 들어간 순서에 상관없이 가장 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조
- 우선순위 큐를 구현하기 위해서 일반적으로 힙을 사용
  - 구현 방식에는 힙 외에도 배열, 연결 리스트로 구현 가능
  - 힙 방식이 최악의 경우라도 시간 복잡도 O(logN)을 보장하므로 일반적으로 완전 이진트리 형태의 힙을 이용해 구현

#### 해시 테이블 (HashTable) / 시간 복잡도 설명

- (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용
  - 내부적으로 배열(버킷)을 사용하여 데이터 저장하므로 속도 빠름
- Key값에 해시함수를 적용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조
- 고유한 index로 값을 조회하기 때문에 평균적으로 O(1)의 시간복잡도 유지
- 해시의 index값이 충돌이 발생한 경우 충돌된 index값에 대해 연결된 데이터들을 조회하여 원하는 값을 조회하기 때문에 O(N)까지 증가 가능성 존재

#### HashMap과 HashTable 차이점

- 정리: 동기화 지원 여부와 Null 값 허용 여부에 차이
- HashTable
  - 동기화 고려 필요한 상황 하 병렬 처리를 할 때 Thread-Safe
  - Null 값 허용하지 않음
- HashMap
  - 병렬 처리를 하지 않을 때 Thread-Safe 하지 않음
  - Null 값 허용

#### Array의 특징, 장점 및 단점에 대한 설명

- 데이터를 순차적으로 저장
- 데이터에 순서 존재, 0부터 시작하는 인덱스 존재
- 인덱스를 통해 특정 요소를 찾고 조작 가능
- 데이터 중간에 요소가 삽입되거나 삭제되는 경우 그 뒤의 모든 요소들을 한 칸씩 뒤로 밀거나 당겨줘야 하는 단점 존재
- 정보가 자주 삭제되거나 추가되는 데이터를 담기에는 부적절
- 적용의 좋은 예
  - 주식 차트
  - 날짜 별로 주식 가격이 차례대로 저장되어야 하는 데이터
  - 순서가 없는 자료구조 사용 시 날짜별 주식 가격 확인이 어렵고 매번 전체 자료를 읽어 들이고 비교해야 하는 문제 발생

#### Stack과 Queue의 실사용 예

- 자바의 스택 메모리 영역
  - 지역 / 매개 변수의 데이터 값이 저장되는 공간
  - 메소드 호출 시 메모리에 할당되고 종료되면 메모리가 해제되는 LIFO 구조
- OS의 스케쥴러

#### Data structure 키워드 정리

- Direct Address Table
- Stack
- Hash Table
- Hash Function
- Dictionary
- Collision
  - open addressing
  - separate chaining
- Random Access
- Time Complexity
- Space Complexity
- Memory