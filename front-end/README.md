#### 홈페이지가 사용자에게 보이는 순서 (브라우저 렌더링 과정)

- [키워드-흐름]
  - HTML
  - DOM
  - CSSOM
  - Render Tree
  - Rendering
- [간략흐름]
  - [불러오기-단계] 주소 입력 후 서버로부터 HTML 파일 입수
  - [파싱-단계] HTML 문서 파싱하여 DOM 객체 생성
  - [파싱-단계] CSS 파싱하여 CSSOM 객체 생성
  - [렌더링-트리-생성-단계] DOM과 CSSOM 을 렌더 트리로 결합 (렌더링 목적)
  - [렌더링-단계] 렌더링 트리를 탐색하면서 렌더링 시작
- [상세내용]
  - [불러오기-단계] 주소창에 입력된 주소로 서버 찾기
  - [불러오기-단계] DNS가 도메인 name 부분을 DNS 서버에서 해당하는 IP 검색
  - [불러오기-단계] 서버에서 HTML 파일을 클라이언트로 송신
  - [파싱-단계] 웹 엔진의 파서가 HTML 문서는 파싱되어 DOM 객체를 생성.
  - [파싱-단계][css] 중간에 CSS 파일을 로드하는 link 태그 또는 style 태그를 만나면 DOM 생성 중지
  - [파싱-단계][css] CSS를 파싱하고 CSSOM을 생성
  - [렌더링-트리-생성-단계] 만들어진 DOM, CSSOM은 렌더링을 위해 렌더 트리로 결합
    - [참고내용] 렌더링: 브라우저에 시각적으로 출력하는 것
  - 만약 script 태그를 만나면 CSS와 동일하게 JS 코드를 실행하기 위해 파싱을 중단
  - JS 엔진 실행하고 JS 코드 파싱
  - [렌더링-단계] 렌더링 트리를 탐색하면서 렌더링 시작
  - 참고
    - [참고내용] 자바스크립트가 DOM, CSSOM 을 변경하는 경우 리렌더링을 하게 됨.
      - 리플로우: 레이아웃 재 계산
      - 리페인트: 재결합된 렌더 트리를 기반으로 다시 페인트
    - [참고내용] script 태그를 만날 때마다 파싱이 중단되는 문제를 async 나 defer를 붙여줌으로써 해결 가능
      - [async]: HTML 파싱, JS 파일 로드가 동시에 진행
      - [defer]: DOM 생성이 완료된 직후, JS의 파싱과 실행이 진행
        - 자바스크립트 안에서 HTML 요소에 접근하는 코드가 있는 경우 사용

#### 변수 생성 단계

- 선언 단계 (Declaration Phase): 변수 객체를 실행 컨텍스트에 등록
- 초기화 단계 (Initialization Phase): 등록된 변수의 메모리를 확보.
- 할당 단계 (Assignment Phase): 초기화된 변수에 실제 값을 할당

#### 호이스팅

- 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것.
- 코드 실행 전 변수/함수 선언이 해당 스코프의 최상단으로 끌어 올려진 것 같은 현상.
- 변수, 함수의 선언부가 위치한 인접 스코프의 시작 시점에서 해당 식별자의 관측이 가능한 현상.
- 코드 실행 전 이미 변수/함수 선언이 저장되어 있기 때문에 선언문보다 참조/호출이 먼저 나와도 오류 없이 동작함.

#### 렉시컬 스코프 (Lexical scoping)

- 함수를 어디서 호출하는지가 아닌 어디에 선언하였는지에 따라 결정되는 것
- 함수의 선언에 따라 상위 스코프를 결정
- 정적 스코프 (Static scope)

#### 스코프 체인 (Scope chain)

- 일종의 리스트.
- 전역 객체와 중첩된 함수의 스코프 레퍼런스를 차례로 저장하고 각각의 스코프가 어떻게 연결(Chain) 되고 있는지 보여주는 것
- 자기 자신의 스코프를 제외하고 자신과 가장 가까운 변수 객체의 모든 스코프들
- 개발자 도구 내 console.dir() 사용 (ex. [[Scopes]])

#### 실행 컨텍스트 (Execution Context)

- 작성한 코드가 실행되는 환경.
- 자바스크립트의 핵심원리
- LIFO(Last In, First Out) 구조 스택
- 실행되면 엔진이 스코프 체인을 통해 렉시컬 스코프를 먼저 파악 시도.
- 2가지의 실행 컨텍스트 존재
  - 글로벌 실행 컨텍스트 (Global Execution Context)
    - 코드 실행되기 전에 생성
    - 하나의 전역 실행 컨텍스트 만이 존재 (앱 종료될 때까지 유지)
  - 함수 실행 컨텍스트 (Functional Execution Context)
    - 전역 실행 컨텍스트가 생성된 이후 함수가 실행(호출)될 때마다 새로운 실행 컨텍스트가 작성됨.

#### 클로저란, 원리와 사용 이유, 사용법

- 반환된 내부함수가 자신이 선언됐을 때의 환경(렉시컬 환경)인 스코프를 기억하여 자신이 선언됐을 때의 환경 (스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수.
- 자신이 생성될 때의 환경(렉시컬 환경)을 기억하는 함수
- 함수 안의 함수
- 클로저 모듈 패턴 활용한 캡슐화 구현 가능
- 데이터 보존 가능
  - 외부 함수의 실행이 끝나더라도 외부 함수 내 변수 사용 가능
- 모듈화에 유리
  - 데이터와 메소드를 묶어다닐 수 있으므로

#### GET, POST

- GET: 가져온다는 개념
  - 서버로부터 어떤 데이터를 가져와서 보여줄 때 사용
  - 값, 내용, 상태 등을 바꾸지 않는 경우에 사용
  - 서버의 어떠한 리소스로부터 정보를 요청하기 위해 사용되는 메소드
  - 멱등성 O
  - ex. 게시판 글 목록 보기
- POST: 수행한다는 개념
  - 서버 상의 데이터 값이나 상태를 바꾸기 위해 사용
  - 리소스를 생성 / 업데이트하기 위해 서버에 데이터를 보내는 데에 사용
  - 멱등성 X
  - ex. 게시판 글 수정 / 저장

#### 자바스크립트 함수 호출시 전달되는 값들

- 함수 내 명시된 인자값
- arguments 객체
- this

#### 자바스크립트의 this

- 자바스크립트는 this에 바인딩할 객체가 동적으로 바인딩
  - 함수가 호출될 때 함수가 어떻게 호출되었는지에 따라 객체 동적 바인딩
  - 함수호출, 메소드 호출, 생성자 함수 호출, apply/call/bind 호출

#### 브라우저 저장소 종류와 차이점

- [Web-Storage] <-- HTML5에서 추가된 스펙, 아래 2가지 존재
  - [Local] Storage
  - [Session] Storage
- [Cookie]
  - 하나의 사이트에서 저장할 수 있는 최대 쿠키 수는 20개
  - 저장할 수 있는 최대 쿠키 크기 4KB
  - 쿠키 설정 이후 모든 웹 요청은 쿠키정보를 포함하여 서버로 전송

#### HTML

- [Hypertext-Markup-Language], 하이퍼텍스트를 작성하기 위해 개발되었음
- 웹 문서를 만들기 위한 기본적인 웹 언어
- 웹의 구조를 담당 (구조 구성, 예: 제목, 문단, 표, 이미지, 동영상 등의 구조 구성)
  - [html-태그]: HTML 문서의 최상위 Root, head와 body 태그 포함
  - [head-태그]: 문서에 대한 메타데이터(HTML 문서에 대한 정보) 정의
    - style, script, link, meta 태그 등
  - [body-태그]: 본격적으로 브라우저에 표현되어야 할 태그들이 들어가는 부분.
- HTML (기획자)

#### HTML 태그 (TAG)

- HTML의 요소 (Element)
- HTML 문서를 구성하는 기본 단위.
- 웹 문서에 어떤 표시를 해주는 것.
  - (예. 글 작성, 크기 변경, 모양 지정 등)

#### 빈 태그 (Empty Tag)

- 종료되는 닫히는 태그가 존재하지 않는 태그.
  - (태그 사이에 내용을 넣을 수 없다.)
- 되도록이면 종료 태그를 붙이는 연습 필요.
  - (HTML5 에서는 붙이지 않아도 정상 동작, 혼용되어 사용되는 상황)
- 빈 태그들은 그 자체로는 역할을 하지 못함.
- 주로 속성과 값을 입력하는 것이 기본적인 사용법.

#### HTML 글자 (Inline), 상자 (Block) 개념

- 요소가 화면에 출력되는 특성
  - 인라인, 블록, 인라인 블록 그리고 테이블 요소 존재.
  - 상세 설명
    - [인라인-요소]: 글자를 만들기 위한 요소들.
      - 포함한 컨텐츠 크기에 따라 자동으로 줄어드는 성질
      - 글자 요소는 가로, 세로 사이즈 지정 불가
      - 가로에 대한 패딩, 마진만 지정 가능
        - 예. span, img, a(anchor), br(break), span, label
    - [블록-요소]: 레이아웃을 만들기 위한 요소들.
      - 부모 요소의 크기만큼 자동으로 늘어남. (가로 너비로)
      - 세로 넓이는 컨텐츠 크기 만큼 줄어드는 성질.
      - 블록 / 글자 요소 포함 가능
      - 가로, 세로에 대한 패딩, 마진 지정 가능
        - 예. div, h1~6, ul(unordered), li, ol(ordered), p
    - [인라인-블록-요소]
      - 수평으로 쌓이는 특성
      - 가로, 세로 크기 지정 가능
      - 예. input, label 안의 input
    - [테이블-요소] (크게는 블록 요소, 테이블 요소는 조금 더 세부적인 블록 요소)
      - [tr](table row): 행, [td](table data): 열
      - 예. table

#### HTML 태그의 class 와 id

- [class] 요소를 지칭하는 중복 가능한 이름
  - 태그 내에 클래스 이름 지정, CSS 파일 내에서 .클래스 이름으로 속성 지정 가능
- [id] 요소를 지칭하는 고유한 이름
  - 태그 내에 아이디 지정, CSS 파일 내에서 #아이디 이름으로 속성 지정 가능
- [data-이름] 요소에 데이터를 지정
  - 예. [html] data-dummy-data --> [js] element.dataset.dummyData

#### CSS 기본 문법

- 선택자 { 속성: 값; }
  - 선택자: 스타일(CSS)을 적용할 대상(Selector), HTML의 특정한 요소 (태그).
  - 속성: 스타일(CSS)의 종류(Property)

#### CSS 작성 방식

- [내장-방식]
  - 유지보수 측면에서 좋지 않음.
  - 선택자 (태그) 존재
- [인라인-방식]
  - 선택자 (태그) 없음 (원하는 요소에 직접적으로 스타일을 작성하므로)
  - 태그의 style 속성에 직접 스타일을 작성하는 방식
  - 유지보수 측면에서 좋지 않음.
- [링크-방식]
  - link 태그 사용하여 외부 CSS 문서를 연결하는 방식
  - 병렬 연결 방식
    - 여러 개의 link 태그 활용한 다수의 css 파일 로드
- [@import-방식]
  - 'import 규칙'이라 명명됨.
  - CSS 문서 안에서 또 다른 CSS 문서를 가져와 연결하는 방식
  - 직렬 연결 방식 (html --> main.css --> main2.css)
    - import 를 하는 css 코드 해석이 완료된 후에 수행 되므로 처리 지연이 발생할 수 있음.
    - 이를 활용해서 일부러 지연 처리를 할 수도 있음.

#### CSS 선택자 종류

- 일반
  - 전체 선택자 (Universal Selector): '\*'
  - 태그 선택자 (Type Selector): 태그
  - 클래스 선택자 (Class Selector): .클래스
  - 아이디 선택자 (ID Selector): #아이디
- 복합
  - 일치 선택자 (Basic Combinator): 태그.클래스
  - 자식 선택자 (Child Combinator): 태그 > .클래스
    - ex. ul, li 관계 내 ul > .orange
  - 하위(후손) 선택자 (Descendant Combinator): 태그 .클래스
  - 인접 형제 선택자 (Adjacent Sibling Combinator): .클래스 + 태그
    - 다음 형재 요소 1개 선택 (아래쪽)
  - 일반 형제 선택자 (General Sibling Combinator): .클래스 ~ 태그
    - 다음 형제 요소 모두 선택 (아래쪽)

#### CSS 가상 클래스 선택자 (Pseudo-Classes)

- :hover
  - 참고) 전환효과: transition 1s;
- :active
  - 마우스 클릭하고 있는 동안에만 효과 처리
- :focus
  - select, textarea, input 등 포커스 가능한 태그에만 가능.
  - 포커스를 강제로 넣고 싶다면 원하는 태그의 글로벌 속성 tabIndex 값을 -1로 설정.
- :first-child
  - 형제 요소 중 첫째 선택.
- :last-child
  - 형제 요소 중 막내 선택.
- :nth-child(n)
  - 형제 요소 중 n째라면 선택.
  - 다른 ex.
    - nth-child(2n) <-- n은 0부터 시작 (Zero-based numbering)
      - 0, 2, 4, 6...
    - nth-child(2n+1)
      - 1, 3, 5, 7...
- :not(span) - 부정선택자
  - span 이 아닌 요소 선택
