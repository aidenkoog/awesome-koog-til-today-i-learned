# Keyword

## It organizes keywords about programming and computer world in general.

[![N|Solid](https://cldup.com/dTxpPi9lDf.thumb.png)](https://github.com/aidenkoog)

## Study Keyword.

- 리액트
  - 페이지 상호작용
  - 전통적인 웹 구현 방식 (HTML 요청 -> 서버로부터 HTML 수집)
  - 리액트란 무엇인가?
  - 왜 자바스크립트 대신 리액트를 사용하는가?
  - 리액트 구동되는 메커니즘
  - 리액트 선택 장점
    - 코드의 양
    - 명령형 프로그래밍 X
    - 복잡한 인터페이스 구현에 적합, 선언형 컴포넌트 (컴포넌트 기반)
    - 싱글 페이지 어플리케이션 (서버는 오직 하나의 HTML 만을 전달한다.)
    - 추가적인 기능이 필요한 경우 외부 라이브러리 설치 필요
  - 프레임워크 / 라이브러리 차이점
    - 앵귤러 - 처음부터 타입스크립트 수용 / 컴포넌트 중심 / 기능 많음
    - 뷰 - 컴포넌트 기반, 기능은 리액트보다는 많음
    - 리액트, 앵귤러, 뷰 간의 차이 / 선택 기준은 무엇인가?
  - props, state, 컴포넌트 스타일링, 리액트 훅, Refs, Context API, 리덕스
  - 데이터베이스, HTTP, 라우팅, 배포 방법, 넥스트 JS
  - 모던 자바스크립트
  - 비주얼 스튜디오 코드
  - let, const
  - 화살표 함수 (키워드 this 이슈)
  - Export / Import Modules (default, as, \*) / Named Import
  - Class, Property, Method (클래스와 화살표 함수 간의 관계)
  - 연산자
    - Spread 연산자 (배열의 원소를 펼칠 때, 클래스 안에서 … 사용법)
    - 레스트 연산자 (함수에서 사용, filter 연산)
  - Destructuring
  - 객체와 배열은 참조형 자료 타입, 재할당한다면 값이 아닌 포인터를 복사하는 것, 자체를 복사하고 싶으면 즉, 진짜로 복사하고 싶다면 프로퍼티를 복사해야 한다.
  - 자바스크립트 ES6, 7 등 버전에 따른 차이점
  - 배열함수 (map)
  - 모질라 자바스크립트 네트워크에서 추가 설명
  - JSX, Component Usage, Data Handling
  - 리액트는 컴포넌트에 대한 모든 것 (리액트 = 컴포넌트)
  - 왜 컴포넌트인가 ? : 재사용성, 관심사 분리 OOP 적 완성을 위한 목적
  - 커스텀 HTML Element 구성 => 리액트
  - 앱 설치 및 실행에 필요한 요소들
    - Node.js (자바 스크립트 런타임)
    - npm, yarn install
  - index.js, index.html (div id="root")
  - JSX: 작성 용이, 브라우저에서 해석 가능, 화면 뒷단에서 변경 (개발자 도구 (크롬))
  - 기본적으로 커스텀 HTML 요소
  - 관례: 첫단어 대문자, 카멜 케이스 적용
  - 가독성을 위해 괄호로 태그를 묶는다. (return (div…div))
  - text 태그없이 div 내에 텍스트 작성 가능 (경고 메세지 제거 위한 목적)
  - 다른 컨텐츠 주변에서 셀 역할을 하는 컴포넌트를 생성하고 싶다면 ?
    - 각각의 컨텐츠들에서 공통적인 속성을 묶을 때 컴포지션 children prop 사용
    - 재사용 가능한 래퍼 컴포넌트를 만들기 위한 목적
    - 클래스네임 중첩
    - 컴포넌트를 결합할 때 마다 컴포지션 개념을 사용
  - 내부적으로 JSX 문법은 아래와 같이 변환된다.
    - React.createElement() <-- 세가지 인자 필요 (태그 이름, 속성 객체, 컨텐츠 컴포넌트 정보)
    - React.createElement('div', {}, React.createElement('h2', {}, "TEST"), React.createElement(Object, {items: objItems})
  - function 스타일 --> 대체 함수 문법 (화살표 함수)
  - 관례적인 함수 작명법
  - useState
    - 사전 지식
      - 컴포넌트는 JSX 를 반환하는 함수형이므로 누군가는 호출을 해줘야 한다.
      - JSX 는 함수 불러오기의 나열 / 모든 것은 index.js 에서 부터 시작
      - 기본적으로 리액트는 화면 렌더링을 반복하지 않는다.
      - 그러므로 리액트에게 어떤 것이 변경되었고 특정 컴포넌트가 업데이트 되어야 한다고 알려줘야 함.
    - 컴포넌트 함수 바깥 및 중첩된 함수 내에서는 동작하지 않음
    - 배열을 반환
    - 컴포넌트 함수는 useState 를 업데이트하는 함수, useState를 초기화했던 부분에서 다시 시작된다. (set을 할 경우)
    - setXXX 는 리액트에게 상태를 변경하고 싶다고 알리고 useState 에게 state가 등록된 컴포넌트가 업데이트 되어야 한다고 리액트에게 알린다.
    - setXXX 는 바로 값을 변경하지 않고 대신 이 state의 업데이트를 예약한다. (그래서 다음 라인에서 로그 출력 시도를 해도 값이 그대로임)
    - State 는 컴포넌트 인스턴트 별로 나뉘어져 있음.
    - 가장 최근에 설정된 값을 항상 보여준다.
    - 여러가지 상태를 업데이트하는 경우 객체로서 업데이트도 가능
    - 이전 상태에 의존하는 상태 업데이트 (ex. setUserInput((prevState) => { return { ...prevState, enteredName: event.name}) <-- 스냅샷 이용 방법 권장
  - 입력창 처리 : form 태그 (label, input 태그)
    - onChange (event 객체, event.target.value)
    - form 태그 onSubmit (button type 이 'submit')
    - 기본적으로 서브밋을 하면 웹페이지가 갱신된다. (event.preventDefault())
    - input 태그의 value 속성
  - 부모 <-> 자식 컴포넌트 간 통신 방법
  - Lifting State Up (자식 --> 부모 --> 다른 자식)
  - select 태그 (option 태그)
  - 컴포넌트 용어 (참고)
    - 프레젠테이셔널 / 덤프 컴포넌트 / 무상태 컴포넌트
    - 스마트 / 상태 유지 컴포넌트
  - {} 와 배열 map() 활용한 동적 리스트 구성
  - 아이템 keys 이해 --> 리액트가 모든 아이템을 정확하게 인식할 수 있게 하기 위한 목적
  - 배열 filter 연산 (props.items.filter(item => { return item.date.getFullYear().toString() === filteredYear})
  - JSX 구문 복잡성을 줄이고 컴포넌트 함수 상단에서 연산을 처리하는 방향으로 코딩
  - 조건부 내용 출력 건 => && 연산 뒤의 내용이 출력되므로 이를 활용 가능
  - JSX 코드를 변수에 저장하는 것 가능
  - ul, li 태그
  - 동적 스타일 추가
    - 동적 스타일 추가 (style): style={{}}
    - 동적 스타일 추가 백틱 문자열 기호 사용한 클래스 네임
    - 패키지: styled components
    - ex. const Button = styled.button``
    - & input:focus, & label
    - props 사용한 동적 스타일 구성 ($와 {}활용)
    - 미디어 쿼리 @media
    - CSS 모듈: Button.module.css 등
  - Users -> src -> 원본소스 확인 -> 브레이크 포인트 설정
  - DevTools (Chrome Extension)
  - label 태그: htmlFor
  - form 태그 onSubmit (기본 동작은 누르면 웹페이지가 갱신됨)
  - import classes from './Xxx.module.css'
  - 자바스크립트 파일이 아닌 경우에는 Import 시 확장자 작성 필요
  - Fallback 처리: type={props.type || 'button'} <- 전달된 타입이 없는 경우에 대한 Fallback 처리
- 자바스크립트
  - 데이터 타입을 자동으로 유추
  - 동적 해석 프로그래밍 언어
  - 동적 작업을 위해 필요
  - 브라우저 내에 자바스크립트 엔진 존재 -> 자바스크립트 실행 가능
  - 자바스크립트는 로컬 파일 시스템은 접근 불가
  - 구글 자바스크립트 엔진 V8
  - Node.js (웹 백엔드 / 서버 구축)
  - Node.js 는 컴퓨터에서 직접 실행되기 때문에 파일 시스템 접근 가능
  - DOM (Document Object Model)
  - OOP, Class, Constructor, Prototypes
  - 비동기 처리, Ajax, 브라우저 API
  - 코드 분할
  - 웹팩, Babel, 브라우저 스토리지
  - 자바스크립트 프레임워크
  - 메타 프로그래밍
  - 코드 보안, 성능 최적화, 메모리 누수 방지
  - 자바스크립트 vs 자바 (브라우저에서 직접 지원 X)
  - LiveScript / JavaScript / ECMAScript / ActionScript / jScript
  - 구글 크롬 (개발자 도구) + 비주얼 스튜디오 코드
  - VSCODE: Preferences - Settings - (.vscode) - ex. prettier (코드 포맷팅 수정)
  - 기본 세팅: 자동 세미콜론 + 탭 2칸 + 싱글 따옴표 (Quote)
  - 확장 프로그램 영향 줄이기 위해서는 개발 시 시크릿 모드 권장
  - script src="assets/app.js"
  - 페이지 로드 완료된 이 후 무엇인가를 처리하려면?
  - Case Sensitive / Camel Case Format
  - Snake Case is NOT recommended.
  - "+ - * / % **"
  - 백틱 문자 ($ 사용 가능, 코틀린과 유사), 쌍따옴표 내 싱글 따옴표
  - 템플릿 리터럴 
  - Arrow Function: 코드 양 줄일 수 있고 다양한 형태로 작성 가능
    - const add = (a, b) => a + b;
  - 기본값 함수 매개변수 (const add = (a, b = 2) => a + b;)
- 타입 스크립트
  - 프로그래밍 언어 / 도구
  - 브라우저는 타입스크립트를 실행할 수 없다.
  - 타입 추가 / 브라우저 런타임에서 에러 발생 전 코드의 에러를 미리 식별 가능, 에러가 적은 코드 작성 가능
  - 숫자 연산, 문자열 연결 예제가 대표적인 자바스크립트, 타입스크립트 차이점 예제
  - +number1 + +number2 / typeof === "number"
  - 설치 : npm install -g typescript
  - 타입스크립트 컴파일 방법: tsc xxx.ts -> xxx.js 파일 생성됨
  - 데코레이터, 제네릭, 클래스, 인터페이스
  - 네임 스페이스, 모듈
  - 웹팩 (Webpack): 프론트엔드 웹 개발 시 사용하는 구축 도구
  - VsCode Plugins: Prettier (format document - shortcut), EsLint, Path Intellisense, Material Icon, TSLint
  - lite-server (localhost:3000)
  - node_modules: 타사 패키지와 종속성을 모두 저장하는 폴더
  - Extra Sanity Check
  - 정적 타입, 런타임 중에 변수와 매개변수가 변하지 않음.
  - 타입 추론 (자바스크립트, 타입스크립트)
  - let result = "Result.." / result = 0 (에러) <--- 문자열로 추론
  - 클래스: const person: { name: string; age: number } = { name='', age: 30}
  - any 타입
  - Tuple 타입, Fixed length array.
  - Tuple 타입, Push 기능 관련 이슈
  - Enum 타입 - Enum 왜 사용하는지에 대한 근본적인 질문
  - 문자열보다 숫자를 사용하면 메모리 점유와 코드 양 줄일 수 있음.
  - enum CustomEnum { TEST1, TEST2, TEST3 } / CustomEnum.TEST1
  - 유니언 타입 (예. number | string -> if (typeof input1 === ''number))
    - 런타임 체크 필요한 경우 발생
  - result: 'as-number' | 'as-text' 리터럴 타입
  - 커스텀 유니언 타입: type 으로 정의. 예. type customType = number | string
    - 불필요한 반복 지양, 타입 중심 관리 가능
  - undefined, unknown
  - 컴파일
    - 소스 맵 (크롬 - 개발자도구) : 브라우저와 개발자 도구 간의 다리 역할 sourceMap: true (tsconfig.json)
    - rootDir / outDir (ex. outDir: ./dist, rootDir: ./src)
    - dist
    - remoteComments: true (주석 제거)
    - noEmit: true (산출물 만들지 않기), noEmitOnError (에러 발생 시에는 .js 파일 생성하지 않음)
    - strict, strictNullCheck, Dom의 버튼 객체를 예로 듬. 또는 if (button) xxx
    - strictBindCallApply, ex. clickHandler.bind(null)
    - Debugger for chrome 플러그인 (VsCode) - sourceMap 활성화 필요, launche.json
  - let 과 var 의 변수 유효 범위 ({} 내 var 변수는 {} 바깥에서 참조가능)
  - Arrow Function:
    - const printOutput: (a: number | string) => void = output => console.log(output);
    - if (button) button.addEventListener('click', event => console.log(event));
  - 스프레드 연산자
    - 배열의 푸쉬 동작 원리
    - ex. xxx.push(...bases)
    - ex. const person = { name: "xxx", age: 33 }; const copied = { ...person };
- 공통
  - 테스트 TDD
  - Mockito
  - 테스트 고전파, 런던파
  - 웹접근성, 렌더링 퍼포먼스 개선
  - 이슈 발생 시 이슈 발생 지점 추측 방법
  - SSR, CSR 환경
  - PHP 단점 / 장점 (프레임워크)
  - Cypress 라이브러리
  - Redis / MemCache / EhCache
  - EC2 서버, RDS, SQS
  - 트래픽 처리는 어떻게 하는가?
  - 멀티 마스터?, DB Write IO 임계치 초과했을 때 어떻게 처리하는가?
  - 레플리카 DB - 조회 서비스
  - 사용자 트랜잭션이 자주 일어나는 서비스 동작 / 상황 대처 방법
  - 정부과제 - 연구내용/노트
  - TF (Team Fortress)
  - 경력 정리
    - 나는 무슨 개발자인가? 주 도메인과 서브 도메인은 무엇인가?
    - 경험: 회사, 기간, 주력 포지션, 대표 구현 서비스, 경험 내용
    - 역량: 기여 주요 역할 / 상세한 기여 내용
    - 업무 진행 사용 기술 (언어, 프레임워크, 라이브러리, 플랫폼)
    - Confluence, Blog, Github 활용
    - 업무 프로젝트 (프로젝트 진행 이유 / 요구사항 + 기술 + 애로사항 극복 내용 + 유지보수 내용)
    - 교육 사이트 활용 → 교육 이후 Confluence / Blog에 정리하고 세미나 자료를 만드는 것이 효과적.
    - 작성한 문서의 카테고리화
    - 도서 / 기사 글
    - 협업 중 일어난 상황 정리 / 학습 중 발생한 어려움 / 이슈 처리 중 어려움
  - SaaS (Software as a Service, Saas)
  - Jenkins / SpringBatch
  - 기술 블로그
  - Ruby, Rails, ORM, N+1, fetchJoin, persistence context (Java)
  - Equals, HashCode, Generic, RDBMS Index
  - Three.js
  - 로그인 기능 / 페이지 구현, 사용자 구분은 어떻게 하는가? (세션 관리법)
  - 쉘 스크립트 배포 스크립트, 무중단 배포환경, 리턴문 차이점
  - JPA N+1, fetchJoin, 실제 쿼리 결과물
  - 레퍼런스 타입, 원시 타입 차이 / 특징
  - 단방향, 양방향 바인딩
  - 쿠키가 HTTP 어느 파트에 있는가?
  - 네트워크 예외처리 방법
  - 헤더, 바디에 대한 내용
  - 장애상황 대처 (화면이 안뜰때 확인할 수 있는 포인트, JS 다운로드가 느릴때 확인 포인트)

