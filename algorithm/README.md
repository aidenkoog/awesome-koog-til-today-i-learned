#### 알고리즘

- 아랍의 수학자, 알콰리즈미 이름에서 유래
- 문제 이해 후 문제 해결을 위한 단계를 세우고 이를 적용해 문제를 해결하는 과정
  - 컴퓨터에게 명령하기 위해서는 일의 순서를 세분화해서 명령을 내려야 함
- 절차
- 문제나 과제를 해결하기 위한 처리 절차를 하나하나 구체적인 순서에 따라 표현한 아이디어나 생각

#### 알고리즘의 조건

- 입력
- 출력
- 명확성
- 유한성(종결성)
  - 명령어 수행 후 유한 시간 내에 종료
- 효율성
  - 모든 과정은 명백하게 실행 가능 / 검증 가능한 것이어야 함

#### 프로그램 / 프로그래밍 개념

- 프로그램: 알고리즘을 프로그래밍 언어로 기술한 것
- 프로그래밍: 프로그램을 작성하는 작업
- 프로그래밍 언어: 컴퓨터에 지시하기 위한 인공 언어
- 프로그램 작성 흐름
  - 기획 => 설계 => 프로그래밍(코딩) => 테스트 / 디버깅 => 문서 작성

#### 알고리즘 분석 방법

- 시간 복잡도 (Time Complexity) - 속도
- 공간 복잡도 (Space Complexity) - 메모리 사용량
- 참고.
  - 일반적으로 복잡도를 이야기할 때 이는 시간 복잡도를 의미
  - 알고리즘은 시간을 더 중요시

#### 알고리즘의 세가지 기본형 (기본 구조) 설명

- 순차 구조
- 선택 구조
- 반복 구조

#### 빅오 표기법 설명 (Big-O notation)

- 알고리즘 최악의 실행 시간 표기, 최소한 보장되는 성능 표기, 가장 일반적으로 사용
  - 그 외 표기법: 빅 오메가 (최상의 실행 시간), 빅 세타 (평균 실행 시간)
- 상수항 / 계수 무시
- 최고차항만 표시
- 종류
  - 실행 속도 O(1) < O(log N) < O(N) < O(N log N) < O(N^2) < O(2^N) <-- 가장 느림

#### 정렬 알고리즘에서 Stable, Unstable에 대한 설명

- 순서 : 같은 값의 정렬 후 위치
- 각각에 해당하는 알고리즘에 대해 설명
  - Stable: 삽입, 합병
  - Unstable: 선택, 힙, 퀵
- 구체적인 구현 내용
  - 합병: 분할
  - 퀵: 피벗
- 시간 복잡도
  - 합병: nlogn
  - 퀵: nlogn ~ n^2 (최악의 경우)
- 각각의 장단점 / 언제 사용하면 좋은지?
  - 시간 복잡도, In-place, Stable

#### 동적 프로그래밍(Dynamic Programming) 설명

- 주어진 문제를 풀기 위해서, 문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음, 그것을 결합하여 해결하는 방식
- 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 답을 여러 번 계산하는 대신 한 번만 계산하고 그 결과를 재활용하는 메모이제이션(Memoization) 기법으로 속도를 향상 시킬 수 있음

#### 동적 프로그래밍(Dynamic Programming)의 두 가지 조건 설명

- 다음의 조건을 만족해야 함
  - Overlapping Subproblem(중복되는 부분문제): 주어진 문제는 같은 부분 문제가 여러번 재사용됨
  - Optimal Substructure(최적 부분구조): 새로운 부분 문제의 정답을 다른 부분 문제의 정답으로부터 구할 수 있음

#### 재귀 알고리즘과 재귀의 시간 복잡도 설명

- 함수 내부에서 함수가 자기 자신을 또 다시 호출하여 문제를 해결하는 알고리즘
- 자기가 계속해서 자신을 호출하므로 끝없이 반복되게 되므로 반복을 중단할 조건이 반드시 필요
- 팩토리얼을 계산하는 재귀 함수에서는 T(n) = T(n-1) + c (C는 n과 f(n-1)을 곱하는 비용)을 조회하고 점화식을 계산하면 O(n)이 됨

#### 정렬 알고리즘 설명

- 버블소트
  - 서로 인접한 두 원소를 비교하여 정렬하는 알고리즘
  - 0번 인덱스부터 n-1번 인덱스까지 n번까지의 모든 인덱스를 비교하며 정렬
  - 시간복잡도 O(n2)
- 힙소트
  - 주어진 데이터를 힙 자료구조로 만들어 최대값 또는 최소값부터 하나씩 꺼내서 정렬하는 알고리즘
  - 힙소트가 가장 유용한 경우는 전체를 정렬하는 것이 아니라 가장 큰 값 몇개만을 필요로 하는 경우
  - 시간복잡도는 O(nlog2n)
- 병합소트
  - 주어진 배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할/정복 알고리즘
  - 시간복잡도는 O(nlog2n)
- 퀵소트
  - 매우 빠른 정렬 속도를 자랑하는 분할 정복 알고리즘 중 하나로 합병정렬과 달리 리스트를 비균등하게 분할
  - 피벗을 설정하고 피벗보다 큰값과 작은값으로 분할하여 정렬
  - 시간복잡도
    - 최선 / 평균의 경우: O(nlog2n)
    - 리스트가 계속해서 불균등하게 나눠지는 경우는 O(n2)
- 삽입소트
  - 두 번째 값부터 시작하여 그 앞에 존재하는 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘
  - 시간 복잡도
    - 평균: O(n2)
    - 가장 빠른 경우는 O(n)
    - 최악의 경우: O(n2)

#### n개의 배열에서 k(k<=n) 번째로 큰수를 찾는 알고리즘 설명

- 일반적으로 퀵정렬을 사용
- 퀵정렬을 사용하면 정렬이 불필요한 부분들을 정렬하면서 효율적이지 못하게 되는 문제 발생
- 퀵선택 알고리즘은 퀵정렬을 한 후에 피봇과 K를 비교하여 아래와 같이 수행
  - pivot의 인덱스가 k와 같은 경우 : 그대로 그 인덱스의 값을 리턴
  - pivot의 인덱스가 k보다 작은 경우 : pivot의 인덱스+1부터 마지막 인덱스까지 다시 Partition함수에 넘겨준다
  - pivot의 인덱스가 k보다 큰 경우 : 첫번째 인덱스부터 pivot의 인덱스-1까지 다시 Partition함수에 넘겨준다
- 퀵정렬과 퀵선택 알고리즘 차이점
  - Pivot의 인덱스가 7이고 K가 5인 경우에, 피봇의 오른쪽 부분은 재귀 함수를 돌지 않아 한 쪽만으로 재귀를 진행
  - 퀵선택 알고리즘의 시간복잡도: n+n/2+4/n+....1=O(n)

#### 허프만 코딩 설명

- 문자의 빈도를 이용해 압축하는 방법으로 빈도가 높은 문자에 짧은 코드를 부여
- 접두부 코드와 최적 코드를 사용
  - 접두부 코드: 문자에 부여된 코드가 다른 이진 코드의 접두부가 되지 않는 코드
  - 최적코드: 인코딩된 메세지의 길이가 가장 짧은 코드

#### 알고리즘 테스트의 목적

- 문제 해결력
- 예외 상황과 경계값 처리
- 코드 가독성과 중복 제거 등 관련한 코드의 품질
- 언어 자체에 대한 이해도
- 효율적인 로직
- => 문제를 어떻게 창의적으로 해결을 할 것인가를 측정하기 위한 목적

#### 알고리즘 문제 해결을 위한 접근법 및 생각법 정리

- 접근법
  - 문제에 대한 능동적, 공격적 받아들임
  - 필요한 정보를 추가적으로 요구
  - 문제 자체에 대한 완벽한 이해 필요
  - 문제를 익숙한 용어로 재정의 / 해결하기 위한 정보를 추출 <== 추상화 과정
  - 추상화된 데이터를 바탕으로 문제 해결 계획 수립 (사용할 알고리즘과 자료구조 선택)
  - 수립한 계획에 대해 검증 시도
    - Pseudo 코드 작성 또는 의견 수집
  - 계획 실행
- 생각법
  - 비슷한 문제를 항상 생각하려고 시도
  - 단순한 방법에서 시작해서 점진적 개선 시도
  - 작은 값을 생각 시도
  - 그림으로 그리기 시도
  - 수식으로 표현 시도
  - 풀이 순서를 강제
  - 뒤에서부터 생각
