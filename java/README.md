#### 자바의 특징 설명

- 자바는 객체지향 프로그래밍 언어
- 기본 자료형을 제외한 모든 요소들이 객체로 표현
- 캡슐화, 상속, 다형성이 잘 적용된 언어
- 장점
  - JVM 위에서 동작하므로 OS에 독립적
  - GarbageCollector 통한 자동적인 메모리 관리 가능
- 단점
  - JVM 위에서 동작하므로 상대적으로 실행 속도 느림
  - 다중 상속이나 타입에 엄격, 제약이 많음

#### JVM의 역할에 대한 설명

- JVM은 스택 기반으로 동작
- 자바 바이트 코드를 운영체제에 맞게 해석해주는 역할
- 가비지 컬렉션 통한 자동적인 메모리 관리 수행

#### 자바의 컴파일 과정에 대한 설명

- 자바 파일 작성
- 빌드 수행
- Javac 명령 통한 바이트코드 (.class) 생성
- 클래스 로더 통해 JVM 메모리 내로 로드
- 실행엔진을 통해 컴퓨터가 읽을 수 있는 기계어로 해석 (각 OS에 맞는 기계어)

#### GC 설명

- Garbage Collector
- 동적으로 할당했던 메모리 영역 중에 필요없어진 영역을 해제하는 기능
- C는 사용자가 메모리를 사용 후 해제해줘야 하나 자바는 자동으로 메모리에서 제거
- 제거 방식
  - Mark and Sweep 알고리즘 기반 동작
    - 스택의 모든 변수를 스캔
    - 각각 어떤 오브젝트를 레퍼헌스 하고 있는 검색 / Mark
    - Mark 되어 있지 않은 모든 오브젝트들을 힙에서 제거 (Sweep 과정)
    - Marking 작업을 위해 모든 스레드는 중단되는데 이를 Stop the world라 함
- Stop the world 설명
  - GC 실행 전 JVM 이 GC 실행 쓰레드를 제외하고 다른 쓰레드의 모든 작업을 멈추는 것
  - 어떤 GC 알고리즘을 사용하더라도 Stop the world는 발생. 이 시간을 줄이는 것이 관건

#### GC 과정 설명

#### GC 알고리즘 종류 설명

#### 자바 메모리 구성 설명

- 스택
  - 힙 영역에 생성된 오브젝트 타입 데이터의 참조값이 할당
  - 원시타입의 데이터가 값과 함께 할당 (실제값 저장)
  - 쓰레드 하나당 하나씩 할당
- 힙
  - 모든 오브젝트 타입 / 오브젝트를 상속받은 것들은 힙 영역에 할당
  - 단 하나의 힙 영역 존재 (쓰레드들은 힙 영역 공유)

#### 추상메소드와 인터페이스 공통점, 차이점 설명

- 공통점
  - 추상 메소드를 가지고 있어야 함
  - 인스턴스화 불가능 (new 생성자 사용 X)
  - 인터페이스 혹은 추상 클래스를 상속받아 구현한 구현체의 인스턴스를 사용해야 함
  - 인터페이스와 추상클래스를 구현 / 상속한 클래스는 추상 메소드를 반드시 구현해야 함
- 차이점
  - 키워드 (abstract / interface)
  - 사용 가능 변수 (제한 없음 / static final 상수)
  - 접근 제어자 (제한 없음 / public)
  - 사용 가능 메소드 (제한 없음 / abstract method, default method, static method, private method)
  - 상속 키워드 (extends / implements)
  - 다중 상속 가능 여부 (불가능 / 가능)

#### 람다 함수 설명

- 익명 함수 (Anonymous functions)를 지칭하는 용어, 익명 함수들은 공통으로 일급객체라는 특징을 지님
- 람다 대수: 수학에서 사용하는 함수를 보다 단순하게 표현하는 방법
- 장점
  - 코드의 간결성
  - 지연연산 수행
  - 병렬처리 가능
- 단점
  - 호출 까다로움
  - 람다 Stream 사용 시 단순 for / while문 사용 시 성능 감소
  - 과도한 사용은 오히려 가독성을 낮춤

#### 일급 객체 (First Class Citizen) 설명

- 아래 3가지 조건을 충족한 객체를 의미
  - 모든 일급 객체는 변수나 데이터에 담을 수 있어야 함
  - 함수의 파라미터로 전달 가능해야 함
  - 함수의 리턴값으로 사용 가능해야 함
- 자바스크립트, 파이썬이 일급객체 언어이고 C/C++은 아님 (자바의 경우 람다로 일급객체 개념 지원)

#### 스트림 설명

- 자바 8에서 새로 추가된 기능
- 탄생 배경
  - 기존 루프문 처리 문제 (컬렉션 크기가 커지면 루프문의 사용은 성능 저하를 유발)
- 컬렉션 데이터를 선언형으로 쉽게 처리 가능
- 병렬 처리를 별도의 멀티스레드 구현없이도 쉽게 구현 가능
  - stream() / parallelStream()
- Ex.
  - 기존 방식
    - OK 여부 필터링 (for문)
    - 이름 순서대로 배열 정렬 (for문)
    - 고유 번호 출력 (for문)
  - 스트림 방식
    - 위 세가지 단계를 한줄로 표현 가능
    - stream().filter(..).sorted(..).map(..)
- 스트림 API 특정 정리
  - 선언형: 간결하고 가독성 증대
  - 함수의 조립: 유연성 증가
  - 병렬화: 성능 향상
  - 파이프라이닝: 서로 연결하여 큰 파이프 라인을 구성할 수 있도록 스트림 자신을 반환

#### 스트림과 컬렉션 차이점

- 둘 다 연속된 요소형식의 값을 저장하는 자료구조 인터페이스를 제공
- 차이점
  - 데이터 계산 시점: 컬렉션은 모든 요소가 컬렉션에 추가하기 전에 계산되어져야 하고 스트림은 요청할 때만 요소를 계산하는 고정된 자료구조
  - 반복의 일회성: 스트림은 단 한번만 반복문을 처리 가능, Consumer 개념을 사용해서 한번 소비한 요소에 대해서는 접근 불가능
  - 외부 / 내부 반복
    - 외부반복: 컬렉션은 개발자가 직접 for/foreach 문법을 사용하여 반복문을 명시해야 하는데 이를 외부 반복이라 함.
    - 내부반복: 스트림은 라이브러리를 사용하는 내부반복 개념 / 작업을 병렬로 처리할 수 있고 더 최적화된 다양한 순서로 처리 가능

#### 스트림 연산 종류 설명

- **중간연산**
  - Ex. filter, map, limit
  - 다른 스트림을 반환하기 때문에 여러개의 중간연산을 연결하여 질의 생성 가능
  - 최종연산 실행 전까지는 아무 연산도 수행하지 않음
- **최종연산**
  - Ex. collect
  - 파이프라인 연산의 결과를 출력
  - 리스트 형태 외 Integer, void 등 다양한 형태로 출력 가능

#### 스트림 사용하는 단계 요약

- 질의 수행할 데이터 소스 (어떤 컬렉션 자료구조인가)
- 스트림 파이프라인을 구성할 중간 연산 (filter, map, limit 등)
- 스트림 연산을 실행하고 결과로 출력할 최종 연산

#### Annotation 설명

- 주석이란 뜻, 인터페이스를 기반으로 한 문법
- 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능 주입 가능
- 해석되는 시점 결정도 가능
- 종류
  - Build-In Annotation
    - JDK에 내장 (Ex. @Override)
  - Meta Annotation
    - 어노테이션에 대한 정보를 나타내기 위한 어노테이션
  - Custom Annotation
    - 개발자가 직접 만들어 내는 어노테이션

#### 제네릭 (Generic) 설명

- 자바에서 안정성 담당
- 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에서 사용하는 것으로, 컴파일 과정에서 타입체크를 해주는 기능
- 컴파일 타임 때 객체 타입을 체크하기 때문에 타입 안정성을 높이고 형변환의 수고로움을 감소시킴
- 코드의 간결함 유지
