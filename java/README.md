#### 자바의 특징 설명

- 자바는 객체지향 프로그래밍 언어
- 기본 자료형을 제외한 모든 요소들이 객체로 표현
- 캡슐화, 상속, 다형성이 잘 적용된 언어
- 장점
  - JVM 위에서 동작하므로 OS에 독립적
  - GarbageCollector 통한 자동적인 메모리 관리 가능
- 단점
  - JVM 위에서 동작하므로 상대적으로 실행 속도 느림
  - 다중 상속이나 타입에 엄격, 제약이 많음

#### JVM의 역할에 대한 설명

- JVM은 스택 기반으로 동작
- 자바 바이트 코드를 운영체제에 맞게 해석해주는 역할
- 가비지 컬렉션 통한 자동적인 메모리 관리 수행

#### 자바의 컴파일 과정에 대한 설명

- 자바 파일 작성
- 빌드 수행
- Javac 명령 통한 바이트코드 (.class) 생성
- 클래스 로더 통해 JVM 메모리 내로 로드
- 실행엔진(JVM)을 통해 컴퓨터가 읽을 수 있는 기계어로 해석 (각 OS에 맞는 기계어)
- (참고) 바이트 코드를 완전한 기계코드로 변환하는 과정에서 일반적인 컴파일 언어보다 속도가 많이 느리다는 단점 있음

#### GC 설명

- Garbage Collector
- JVM의 Heap 영역에서 사용하지 않는 객체를 제거해주는 프로세스
- 동적으로 할당했던 메모리 영역 중에 필요없어진 영역을 해제하는 기능
- C는 사용자가 메모리를 사용 후 해제해줘야 하나 자바는 자동으로 메모리에서 제거
- 제거 방식
  - Mark and Sweep 알고리즘 기반 동작
    - 스택의 모든 변수를 스캔
    - 각각 어떤 오브젝트를 레퍼런스 하고 있는 검색 / Mark
    - Mark 되어 있지 않은 모든 오브젝트 (Unreachable) 들을 힙에서 제거 (Sweep 과정)
    - GC 알고리즘에 따라 파편화된 메모리 정리를 위한 Compact 동작 수행
      - Compact: Heap의 시작 주소로 모아서 메모리가 할당된 부분과 아닌 부분으로 나누는 과정 (조각모음의 느낌)
    - Marking 작업을 위해 모든 스레드는 중단되는데 이를 Stop the world라 함
- Stop the world 설명
  - GC 실행 전 JVM 이 GC 실행 쓰레드를 제외하고 다른 쓰레드의 모든 작업을 멈추는 것
  - 어떤 GC 알고리즘을 사용하더라도 Stop the world는 발생. 이 시간을 줄이는 것이 관건

#### Heap 구조

- Young Generation
  - 새로운 객체들이 할당되는 영역
  - Eden, Survivor 0 / 1 영역 존재
- Old Generation
  - 오랫동안 계속 살아남은 객체들이 있는 영역
- Meta Space
  - GC 발생 시 필요한 클래스와 메소드의 메타 정보가 있는 영역

#### GC 관련 객체들의 참조 방식의 종류

- 힙 내에 있는 다른 객체에 의한 참조
- 자바 스택, 즉, 메소드 내의 지역 변수나 파라미터들에 의한 참조
- JNI에 의해 생성된 객체에 대한 참조
- 메소드 영역의 Static 변수에 의한 참조
- (참고) 유효한 참조가 있는 객체: Reachable 객체 (없는 경우: Unreachable 객체)

#### GC 과정 설명

- 새로운 객체 생성
- Heap의 Young Generation 내 Eden에 삽입
- Eden이 Full 상태가 되면 Minor GC 발생
- Reachable 객체 판단 후 Reachable 객체들은 Survivor 0 영역으로 이동
- Sweep 동작에 의해 Unreachable 객체들 제거
- 살아남은 객체들의 Age 값 증가 (0 -> 1)
- 또 다른 새로운 객체 생성 및 Eden 영역 Full 상태 발생
- Minor GC 발생
- Eden 영역 외 다른 영역에 대해서도 Mark 진행
- Reachable 객체들을 Survivor 1 영역으로 이동
- 반복하다보면 객체들의 Age가 임계점에 도달
- 임계점에 도달한 객체들을 Old Generation 영역으로 이동 (Promoted)
- 위 과정 반복되다가 Old Generation도 Full 상태가 되면 Major GC (Full GC) 수행
- GC 발생 시 GC 수행하는 스레드 외 나머지 스레드들에 대해 JVM이 작업을 중단 시킴 (stop-the-world)
- Minor GC 의 경우 잠깐 멈추나 Major GC 의 경우 소요되는 시간이 길므로 처리 중 앱에서 에러로 이어지는 경우 발생 (흔히 보는 GC에 의한 처리 에러)
  - 개발 레벨에서 긴 참조 지양, 사용한 뒤에 초기화 등의 작업 반드시 필요

#### GC 알고리즘 종류 설명

- Serial GC
- Parallel GC
- Parallel Old GC
- CMD(Concurrent Mark Sweep) GC
- G1(Garbage First) GC

#### 자바 메모리 구성 설명

- 스택
  - 힙 영역에 생성된 오브젝트 타입 데이터의 참조값이 할당
  - 원시타입의 데이터가 값과 함께 할당 (실제값 저장)
  - 쓰레드 하나당 하나씩 할당
- 힙
  - 모든 오브젝트 타입 / 오브젝트를 상속받은 것들은 힙 영역에 할당
  - 단 하나의 힙 영역 존재 (쓰레드들은 힙 영역 공유)

#### 추상 클래스와 인터페이스 공통점, 차이점 설명

- 공통점
  - 추상 메소드를 가지고 있어야 함
  - 인스턴스화 불가능 (new 생성자 사용 X)
  - 인터페이스 혹은 추상 클래스를 상속받아 구현한 구현체의 인스턴스를 사용해야 함
  - 인터페이스와 추상클래스를 구현 / 상속한 클래스는 추상 메소드를 반드시 구현해야 함
- 차이점
  - 추상클래스
    - abstract 키워드 사용
    - 일반 변수 사용 가능
    - 다른 클래스가 추상 클래스 상속받을 때 extends 키워드 사용
    - 생성자 사용 가능
    - 사용 가능 메소드 제한 없음
    - 접근 제어자 사용 제한 없음 (abstract final 동시에 표기 불가)
    - 다중 상속 불가능
    - 상속의 목적: 클래스 확장 및 코드의 재사용
  - 인터페이스
    - interface 키워드 사용
    - interface 내 정의된 메소드들을 반드시 구현해야 함
    - 일반 변수 사용 불가능, static final 상수 사용 가능
    - 생성자 사용 불가능
    - 접근 제어자 public
    - 사용 가능 메소드: abstract method, default method, static method, private method
    - 상속 키워드 implements
    - 다중 상속 가능
    - 상속의 목적: 요구사항 구현

#### 람다 함수 설명

- 익명 함수 (Anonymous functions)를 지칭하는 용어, 익명 함수들은 공통으로 일급객체라는 특징을 지님
- 람다 대수: 수학에서 사용하는 함수를 보다 단순하게 표현하는 방법
- 장점
  - 코드의 간결성
  - 지연연산 수행
  - 병렬처리 가능
- 단점
  - 호출 까다로움
  - 람다 Stream 사용 시 단순 for / while문 사용 시 성능 감소
  - 과도한 사용은 오히려 가독성을 낮춤

#### 일급 객체 (First Class Citizen) 설명

- 아래 3가지 조건을 충족한 객체를 의미
  - 모든 일급 객체는 변수나 데이터에 담을 수 있어야 함
  - 함수의 파라미터로 전달 가능해야 함
  - 함수의 리턴값으로 사용 가능해야 함
- 자바스크립트, 파이썬이 일급객체 언어이고 C/C++은 아님 (자바의 경우 람다로 일급객체 개념 지원)

#### 스트림 설명

- 자바 8에서 새로 추가된 기능
- 탄생 배경
  - 기존 루프문 처리 문제 (컬렉션 크기가 커지면 루프문의 사용은 성능 저하를 유발)
- 컬렉션 데이터를 선언형으로 쉽게 처리 가능
- 병렬 처리를 별도의 멀티스레드 구현없이도 쉽게 구현 가능
  - stream() / parallelStream()
- Ex.
  - 기존 방식
    - OK 여부 필터링 (for문)
    - 이름 순서대로 배열 정렬 (for문)
    - 고유 번호 출력 (for문)
  - 스트림 방식
    - 위 세가지 단계를 한줄로 표현 가능
    - stream().filter(..).sorted(..).map(..)
- 스트림 API 특정 정리
  - 선언형: 간결하고 가독성 증대
  - 함수의 조립: 유연성 증가
  - 병렬화: 성능 향상
  - 파이프라이닝: 서로 연결하여 큰 파이프 라인을 구성할 수 있도록 스트림 자신을 반환

#### 스트림과 컬렉션 차이점

- 둘 다 연속된 요소형식의 값을 저장하는 자료구조 인터페이스를 제공
- 차이점
  - 데이터 계산 시점: 컬렉션은 모든 요소가 컬렉션에 추가하기 전에 계산되어져야 하고 스트림은 요청할 때만 요소를 계산하는 고정된 자료구조
  - 반복의 일회성: 스트림은 단 한번만 반복문을 처리 가능, Consumer 개념을 사용해서 한번 소비한 요소에 대해서는 접근 불가능
  - 외부 / 내부 반복
    - 외부반복: 컬렉션은 개발자가 직접 for/foreach 문법을 사용하여 반복문을 명시해야 하는데 이를 외부 반복이라 함.
    - 내부반복: 스트림은 라이브러리를 사용하는 내부반복 개념 / 작업을 병렬로 처리할 수 있고 더 최적화된 다양한 순서로 처리 가능

#### 스트림 연산 종류 설명

- **중간연산**
  - Ex. filter, map, limit
  - 다른 스트림을 반환하기 때문에 여러개의 중간연산을 연결하여 질의 생성 가능
  - 최종연산 실행 전까지는 아무 연산도 수행하지 않음
- **최종연산**
  - Ex. collect
  - 파이프라인 연산의 결과를 출력
  - 리스트 형태 외 Integer, void 등 다양한 형태로 출력 가능

#### 스트림 사용하는 단계 요약

- 질의 수행할 데이터 소스 (어떤 컬렉션 자료구조인가)
- 스트림 파이프라인을 구성할 중간 연산 (filter, map, limit 등)
- 스트림 연산을 실행하고 결과로 출력할 최종 연산

#### Annotation 설명

- 주석이란 뜻, 인터페이스를 기반으로 한 문법
- 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능 주입 가능
- 해석되는 시점 결정도 가능
- 종류
  - Build-In Annotation
    - JDK에 내장 (Ex. @Override)
  - Meta Annotation
    - 어노테이션에 대한 정보를 나타내기 위한 어노테이션
  - Custom Annotation
    - 개발자가 직접 만들어 내는 어노테이션

#### 제네릭 (Generic) 설명

- 자바에서 안정성 담당
- 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에서 사용하는 것으로, 컴파일 과정에서 타입체크를 해주는 기능
- 컴파일 타임 때 객체 타입을 체크하기 때문에 타입 안정성을 높이고 형변환의 수고로움을 감소시킴
- 코드의 간결함 유지

#### 자바 라이브러리 설명 및 정적 라이브러리와 공유 라이브러리의 차이점 설명

- 자바 라이브러리
  - Java에서는 미리 자주사용되고 유용한 기능을 하는 class들을 만들어 놓고 제공하는데 이때 이 클래스들을 관련된 기능별로 분류하여 패키지단위로 묶어서 관리하는데 이 패키지 파일을 라이브러리라고 함
  Java API는 이러한 클래스들의 코드를 문서로 제공 
- 정적 링크 라이브러리(Static Link Library)
  - .lib으로 표현하며 컴파일 시에 함수가 실행파일에 연결됨
  - 실행 파일에 함수의 코드가 복사되기 때문에 실행파일의 크기가 커지는 단점이 있지만 실행 파일은 완전한 단독 실행 파일이 됨
  - 실행파일에 함수의 코드가 포함되어 있기 때문에 컴파일이 끝나면 lib 파일이 없어도 프로그램 실행 가능
- 동적 링크 라이브러리(Dynamic Link Library)
  - .dll로 표현하며 정적 라이브러리처럼 컴파일 시에 함수가 연결되는 방식이 아닌 런타임시에 함수가 실행파일에 연결됨
  - 실행파일에는 호출할 함수의 정보만 포함되고 실제 함수 코드는 복사되지 않으므로 실행 파일의 크기가 작아짐
  - 실행 파일은 함수에 대한 정보만 가지고 있을 뿐 실제 코드를 가지고 있지 않기 때문에 프로그램 실행시에는 dll 파일이 항상 존재해야 함

#### 전역변수와 지역변수 설명과 용법 정리

- 전역변수
  - 함수 바깥에 선언하여 클래스 전체에서 사용가능한 변수
  - 여러 메소드에서 공통적으로 사용 가능 
- 지역변수
  - 함수 속에 선언하여 해당 함수 속에서만 사용가능한 변수
  - 해당 메소드가 호출되어 메모리를 할당받은 후 종료되면 소멸되어 다시 사용 불가능

#### Java EE와 SE 차이

- Java SE (Java Platform Standard Edition)
  - 데스크탑, 서버, 임베디드를 위한 표준 자바 플랫폼
  - 안드로이드 개발 시 보통 Java SE 사용
- Java EE (Java Platform EnterPrise Edition)
  - 자바를 이용한 서버측 개발을 위한 플랫폼
  - SE에 서버측을 위한 기능 추가하여 SE의 모든 기능 이용 가능

#### getter와 setter를 사용하는 이유 설명

- 메소드를 통해 접근하기 때문에 메소드 안에서 매개변수같이 어떤 올바르지 않은 입력에 대해 사전에 처리할 수 있게 제한하거나 조절 가능하기 때문에 사용

#### DAO와 DTO 개념 설명

- DAO (Data Access Object)
  - 데이터베이스의 데이터에 접근을 위한 객체
  - 데이터베이스에 접근을 하기 위한 로직과 비즈니스 로직을 분리하기 위해서 사용
  - DB를 사용해 데이터를 조회 / 조작하는 기능을 전담하도록 만든 오브젝트
- DTO (Data Transfer Object)
  - VO (Value Object)로 바꾸어 말할 수 있는데 계층간 데이터 교환을 위한 JavaBean을 의미
  - 각 계층간 데이터 교환을 위한 객체를 DTO 또는 VO라고 말함
  - VO는 DTO와 동일 개념이지만 Read Only 속성을 가짐

#### Iterator 설명

- 컬렉션 클래스에 저장된 요소들을 나열하는 방법 제공
- 컬렉션 클래스의 iterator()를 호출해서 Iterator를 구현한 객체를 얻음
- hasNext()
- next() (호출하기 전에 hasNext()호출해서 확인 필요)
- remove(): next()로 읽어 온 요소를 삭제

#### Wrapper Class 사용 이유

- 프로그램에 따라 기본 타입의 데이터를 객체로 취급해야 하는 경우 존재
- 기본 자료형에 대해 객체로서 인식되도록 포장하기 위해 Wrapper Class를 사용

#### 컴파일 에러와 런타임 에러를 비교하여 설명

- 컴파일 에러
  - 구문 오류로 프로그램 컴파일 불가능함을 의미
  - 문법상의 오류로 발생, 에러 발생 포인트를 개발자에게 알려줌
  - 유형
    - 구문 에러
    - 괄호 등의 구문 에러
    - 클래스패스에 누락된 클래스
- 런타임 에러
  - 실행하면서 에러 발생
  - 논리적 결함으로 인해 발생하는 에러, 에러 발생 시 개발자가 역추적하여 원인 파악 필요
  - 유형
    - NPE
    - 0으로 나누는 경우
    - 무한 루프

#### String

- Java.lang Package로 제공되는 자바 문자열 클래스
- 별도 import 없이 사용 가능
- 한번 인스턴스가 생성되면 수정 불가능 (immutable object)
  - 배열로 접근하는 방법을 제공하지 않음.
  - char[] char_arr 는 수정 가능
- 수정하는 방법
  - 새 문자열로 교체
  - toCharArray() 함수 통해 수정 후 다시 new String(temp_arr) 사용하여 문자열로 변경
  - substring 사용한 조합
  - StringBuilder 사용한 조합
- == 연산으로 비교 불가
  - 참고. 자바 힙 영역이 있고 그 안에 Constant String Pool 영역이 있음
  - 리터럴로 선언된 문자열, 리터럴 스트링은 Constant String Pool 영역에 저장
  - new String("") 으로 생성한 문자열, 오브젝트 스트링은 자바 힙 영역에 저장
- == 은 주소 비교, equals 는 주소 내 실제 값 비교

#### String 함수

- charAt(int index)
- length()
- equals
- compareTo(String string)
  - -1, 0, 1
- toCharArray()
- toLower / UpperCase()
- contains(CharSequence s)
- replace(target, replacement)
- split(String regex)
- substring(index, index)
- indexOf

#### 아스키 코드

- 'A': 65, 'a': 97, 'Z': 90, 'z': 122, '9': 57
- char x = 65;
- println('Z' - 'A'); => 25
- println(x); => A
- println((int)x); => 65
- println((char)x); => A
- println(x + 25); => 90
- println((char)(x + 25)); => Z