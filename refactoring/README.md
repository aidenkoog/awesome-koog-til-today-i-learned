#### 리팩토링 개념

- 소프트웨어 공학에서 결과의 변경없이 코드의 구조를 재조정하는 것을 의미
- 가독성 증대, 복잡성 감소, 유지보수를 용이하게 하는 목적
- 버그 수정 / 새로운 기능 추가는 리팩토링이 아님
- 사용자가 보는 외부 화면은 그대로 두면서 내부 논리나 구조를 개선하는 유지보수 행위
- 소프트웨어 설계, 구조 및 구현을 개선하는 동시에 소프트웨어 기능을 보존하는 것
- 소프트웨어를 더 이해하기 쉽고 수정하기 쉽게 만드는 것
- 성능 최적화 X => 코드를 신속하게 개발하게 해주고 코드 품질을 좋게 만들어 주는 것
- 기능 변경 X
- 개발 과정에서 편리한 코드가 되도록 재작성
- 유지 보수의 용이성 요구 => 코드 중복 제거 => 수정 편리 => 코드 품질 상승 => 개발 속도 상승

#### 리팩토링 사용 시기

- 3번 이상의 중복 / 같은 행위
  - 개발 일정 / 계획 감안한 리팩토링 수행
- 기능 추가때마다 리팩토링 수행
  - 현재 코드 유지한 채로 새 기능 추가가 어렵다면 리팩토링 권장
- 버그 수정때마다 리팩토링 수행
- 코드 리뷰때마다 리팩토링 수행
  - 많은 인원 참여는 권장 X

#### 리팩토링 과정 설명

- 단일 모듈 리팩토링 => 테스트 => 정상 동작 여부 => 반복

#### 리팩토링 불필요한 상황 설명

- 현재 코드가 정상동작 하지 않는 상태
  - 리팩토링보다 재작성 필요
- 개발 일정 마감이 다가온 상황

#### 리팩토링 원칙 설명

- Two Hats 원칙
  - 기능 추가 시: 기존 코드 수정 X, 기능 / 테스트만 추가
  - 리팩토링 시: 기존 동작 유지 상태로 내부 구조만 변경

#### 클린 코드, 코드 리팩토링의 관계 설명

- 리팩토링이 조금 더 넓은 의미
- 클린코드: 단순 가독성 증대를 위한 작업
  - 설계부터 잘 이루어져 있는 것이 중요 (기본 코드 작성 과정에서부터 잘 이루어져야 함)
- 리팩토링: 클린 코드 포함한 유지 보수를 위한 코드 개선
  - 결과물 나온 이후 수정 또는 추가 작업때마다 개선해나가는 것이 올바른 방향

#### 클린코드 설명

- 개발자가 보기에 깔끔한 코드
- 이해하기 쉬운 코드
- 클린 코드 작성 팁
  - 유명 코드 컨벤션 설정
  - 핵심 기능 코드는 주석 통한 세부적인 내용 설명
  - 동사 사용
  - 하나의 파일 내 하나의 프로그래밍 언어
  - 참조되거나 수정되는 코드는 기존 코드보다 클린해야 함
  - 매개변수 이름 생략 또는 과도한 축약 금지

#### 자바 코드 리팩토링 방법 및 예제

- 변수 선언과 초기값을 할당하는 부분이 분리되어 있을 이유는 없음
- 간단한 if-else문은 삼항 연산자로 대체 (간결성, 표현력, 유지보수성,성능의 이유)
- if-else 문을 switch로 전환 (가독성, 성능, 유지관리)
- 흐름이 긴 메소드는 분리
- 중복 코드 제거 / 메소드 분리
- 디자인 패턴 적용
- 알고리즘 / 데이터 구조 최적화 (효율적인 알고리즘 선택, 캐싱 및 지연 로드 등 사용 가능)
- 자바 코드 컨벤션 준수
- 들여쓰기 Depth가 3이 넘지 않도록 구현 (2까지만 허용)
  - while문 안에 if 문이 있다면 들여쓰기는 2
  - Depth를 줄이는 가장 좋은 방법은 함수를 분리하는 것
- 함수는 한 가지 일, 즉 단일 책임만 가지도록 최대한 작게 만들기
- 함수의 길이가 15라인을 넘어가지 않도록 구현
- else 사용 금지 (if 조건절에서 값을 반환하도록 설계하면 else 사용 불필요)

#### 리팩토링

- 마틴 파울러
  - 리팩토링 기술을 분류별로 나열

#### 리팩토링 방법

- 코드 스멜 파악

#### 코드 스멜 종류

- 이해가 어려운 이름
  - 함수, 변수, 필드, 클래스, 모듈 등의 이름
  - 기술
    - 함수 선언 변경
    - 변수 이름 변경
    - 필드 이름 변경
  - 상세 기술 내용
    - 함수 선언 변경
      - 함수 이름, 메소드 이름 변경, 매개변수 추가/제거, 시그니처 변경
      - 좋은 이름 찾는 방법
        - 함수에 주석 작성 후 주석을 함수 이름으로 일단 만들기 (가장 중요한 부분)
      - 함수 매개 변수는 함수 내부의 문맥 결정, 의존성을 결정
      - 매개 변수를 다시 받도록 수정하는 법
        - 시그니쳐 변경 (가시성, 이름, 매개변수)
    - 변수 이름 변경
      - 다이나믹 타입 지원 언어에서는 타입을 이름에 넣기도 함
      - 람다식 변수는 n, r등의 방식도 좋고 메소드 레퍼런스 방식 적용 (ex. n -> n...)
      - 예를 들어 A를 가져오는 함수 안에서 A관련 이름이 없는 것은 문제
    - 필드 이름 변경
      - 사용되는 범위가 넓으므로 이름이 중요
      - Record, Dictionary (dicts) 자료형, 자바 14버전부터
      - Record 는 Immutable 한 특징 (public record)
        - 코틀린의 데이터 클래스와 유사
- 중복되는 코드
  - 비슷한지 아닌지 살펴보기 어려움
  - 코드 변경 시 여러 곳을 변경해야 함
  - 기술
    - 함수 추출
    - 코드 분리 (코드가 비슷하나 완전히 동일하지 않은 경우, Slide Statements)
    - 메소드 올리기 (여러 하위 클래스에 동일 코드)
  - 상세 기술 내용
    - 함수 추출
      - 의도와 구현 분리, 의도를 드러내고 있는지, 구현을 드러내고 있는지
      - 함수를 봤을 때 이해하려는 노력이 필요하다면 그것은 구현
      - 한줄 짜리 메소드도 가능 (의도를 잘 드러낼수만 있다면)
      - 거대한 함수 내 주석은 도움 (주석 기준으로 함수화하면 되니까 편함)
      - 순서 정리: 함수 내 기능 파악 후 주석 작성 
      - -> 주석 기준으로 메소드 추출 
      - -> 변경된 메소드들로 다 변경 
      - -> 기존의 주석 메세지는 삭제 
      - -> 주석 삭제해도 알아보기 쉽다면 리팩토링 작업이 제대로 된 것임
    - 코드 정리 (Slide Statements)
      - 코드 위치 조정하면서 비슷한 동일한 코드 찾기
      - 함수에서 사용할 변수를 상단에 미리 정의하지 말고 해당 변수를 실제 사용하는 코드 바로 위에 선언
        - 코드들을 한 블럭 단위로 보는 것이 가능해짐
      - 관련있는 코드끼리 묶은 다음 함수 추출하기 방법으로 코드 정리 가능
    - 메소드 올리기 (Pull Up Method)
      - 중복 코드는 당장 잘 동작하더라도 미래에 버그를 만들어 낼 가능성이 높음
      - 두 메소드가 비슷한 절차를 따르고 있다면 템플릿 메소드 패턴 적용 고려 가능
      - 함수 매개변수화 작업이 선행된 이후에 적용 가능